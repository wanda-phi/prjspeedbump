<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project Speedbump</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Project Speedbump</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="devices"><a class="header" href="#devices">Devices</a></h1>
<p>FTDI has made a great variety of devices.  Here we attempt to categorize all of them.</p>
<p>Note that, at one point, FTDI has spun off its MCU division as a new company, Bridgetek. There are many  device that exist with both FTDI (FTxxx) and Bridgetek (BTxxx) naming and branding.  To simplify things, we just consider all Bridgetek devices to be FTDI devices as well.</p>
<p>Usually, the last letter of a full part name (eg. Q in FT2232HQ) represents the package type (SSOP / QFP / QFN / etc). We usually skip this letter when describing the devices, as it doesn't affect their behavior in any way.</p>
<h2 id="d2xx-devices"><a class="header" href="#d2xx-devices">D2xx devices</a></h2>
<p>D2xx devices are USB peripherial devices that implement the D2xx protocol, originally created for USB—UART bridging. They come in several varieties:</p>
<ul>
<li>the "proper" fixed-function D2xx devices implementing the D2xx protocol in hardware
<ul>
<li>FT8U232A, FT232B, FT232R, FT230X, FT231X, FT234X: single-channel USB—UART bridge</li>
<li>FT8U245A, FT245B, FT245R, FT240X: single-channel USB—FIFO bridge</li>
<li>FT200X, FT201X: single-channel USB—I2C peripherial bridge</li>
<li>FT220X, FT221X: single-channel USB-SPI/FT1248 bridge</li>
<li>FT2232, FT2232H: dual-channel USB—multiprotocol bridge</li>
<li>FT4232H: quad-channel USB—multiprotocol bridge</li>
<li>FT232H: single-channel USB-multiprotocol bridge</li>
</ul>
</li>
<li>preprogrammed MCUs implementing the D2xx protocol in fixed firmware
<ul>
<li>FT4222H: quad-channel USB—SPI/I2C bridge</li>
<li>UMFT4222PROG: programmer board for FT4222H (based on FT51A)</li>
<li>UMFTPD3A: programmer board for FT260/FT4222H (based on FT51A)</li>
</ul>
</li>
<li>programmable MCUs with FTDI-provided libraries that can be used to implement the D2xx protocol in firmware
<ul>
<li>FT8U100A: ???-based MCU</li>
<li>FT51: 8051-based MCU</li>
<li>FT900 series: FT32-based MCU (custom RISC-like 32-bit Harvard architecture)</li>
<li>FT930 series: FT32B-based MCU (a revision of FT32)</li>
</ul>
</li>
</ul>
<p>D2xx devices come with one or more "channel"s, which are essentially independent bidirectional data pipes. They correspond to USB interfaces with one IN endpoint and one OUT endpoint. On the host side, they can be opened and used independently by distinct applications.</p>
<p>The fixed-function D2xx devices as well as FT4222H can be configured through non-volatile memory — some device types use an external EEPROM for that purpose, while others come with on-chip EEPROM or OTP memory.</p>
<p>Almost all D2xx devices allow the designer to provide custom USB vendor and product IDs (as well as string descriptors), making fully reliable detection impossible. However, once something is known to be a D2xx device, the bcdDevice field of device descriptor can be used to determine its exact type:</p>
<div class="table-wrapper"><table><thead><tr><th>bcdDevice</th><th>default VID:PID</th><th># channels</th><th>device</th></tr></thead><tbody>
<tr><td>0001</td><td>0403:8372</td><td>1</td><td>FT8U100A UART "applet"</td></tr>
<tr><td>0200</td><td>0403:6001</td><td>1</td><td><a href="ft8u232a.html">FT8U232A or FT8U245A</a></td></tr>
<tr><td>0400 or 0200</td><td>0403:6001</td><td>1</td><td><a href="ft232b.html">FT232B or FT245B</a></td></tr>
<tr><td>0400 or 0200</td><td>0403:6004</td><td>1</td><td><a href="ft232b.html">FT232B (alternate PID strap)</a></td></tr>
<tr><td>0400 or 0200</td><td>0403:6005</td><td>1</td><td><a href="ft232b.html">FT245B (alternate PID strap)</a></td></tr>
<tr><td>0500</td><td>0403:6010</td><td>2</td><td><a href="ft2232.html">FT2232C, FT2232D</a></td></tr>
<tr><td>0600</td><td>0403:6001</td><td>1</td><td><a href="ft232r.html">FT232R or FT245R</a></td></tr>
<tr><td>0600</td><td>0403:6049</td><td>1</td><td><a href="ft232r.html">FT232RN or FT245RN</a></td></tr>
<tr><td>0700</td><td>0403:6010</td><td>2</td><td><a href="ft2232h.html">FT2232H</a></td></tr>
<tr><td>0800</td><td>0403:6011</td><td>4</td><td><a href="ft2232h.html">FT4232H</a></td></tr>
<tr><td>0900</td><td>0403:6014</td><td>1</td><td><a href="ft232h.html">FT232H</a></td></tr>
<tr><td>1000</td><td>0403:6015</td><td>1</td><td><a href="ft-x.html">FT-X series</a></td></tr>
<tr><td>1400</td><td>0403:601b</td><td>1</td><td>FT4222 mode 3 (unreleased)</td></tr>
<tr><td>1500</td><td>0403:601b</td><td>2</td><td>FT4222 mode 0 (unreleased)</td></tr>
<tr><td>1600</td><td>0403:601b</td><td>4</td><td>FT4222 mode 1 or 2 (unreleased)</td></tr>
<tr><td>1700</td><td>0403:601c</td><td>1</td><td><a href="ft4222h.html">FT4222H</a> mode 3</td></tr>
<tr><td>1800</td><td>0403:601c</td><td>2</td><td><a href="ft4222h.html">FT4222H</a> mode 0</td></tr>
<tr><td>1900</td><td>0403:601c</td><td>4</td><td><a href="ft4222h.html">FT4222H</a> mode 1 or 2</td></tr>
<tr><td>2100</td><td>0403:0fec</td><td>1?</td><td>UMFT4222PROG</td></tr>
<tr><td>2400</td><td>0403:6031</td><td>1</td><td>FT90x (1 channel)</td></tr>
<tr><td>2400</td><td>0403:6032</td><td>2</td><td>FT90x (2 channels)</td></tr>
<tr><td>2400</td><td>0403:6033</td><td>3</td><td>FT90x (3 channels)</td></tr>
<tr><td>2500</td><td>0403:6034</td><td>1</td><td>FT93x (1 channel)</td></tr>
<tr><td>2500</td><td>0403:6035</td><td>2</td><td>FT93x (2 channels)</td></tr>
<tr><td>2500</td><td>0403:6036</td><td>3</td><td>FT93x (3 channels)</td></tr>
<tr><td>2500</td><td>0403:6037</td><td>4</td><td>FT93x (4 channels)</td></tr>
<tr><td>2500</td><td>0403:6038</td><td>5</td><td>FT93x (5 channels)</td></tr>
<tr><td>2500</td><td>0403:6039</td><td>6</td><td>FT93x (6 channels)</td></tr>
<tr><td>2500</td><td>0403:603a</td><td>7</td><td>FT93x (7 channels)</td></tr>
<tr><td>2700</td><td>0403:603e</td><td>1?</td><td>UMFTPD3A</td></tr>
<tr><td>2800</td><td>0403:6040</td><td>2</td><td><a href="ft2232h.html">FT2233HP</a></td></tr>
<tr><td>2900</td><td>0403:6041</td><td>4</td><td><a href="ft2232h.html">FT4233HP</a></td></tr>
<tr><td>3000</td><td>0403:6042</td><td>2</td><td><a href="ft2232h.html">FT2232HP</a></td></tr>
<tr><td>3100</td><td>0403:6043</td><td>4</td><td><a href="ft2232h.html">FT4232HP</a></td></tr>
<tr><td>3200</td><td>0403:6044</td><td>1</td><td><a href="ft232h.html">FT233HP</a></td></tr>
<tr><td>3300</td><td>0403:6045</td><td>1</td><td><a href="ft232h.html">FT232HP</a></td></tr>
<tr><td>3500</td><td>0403:6047</td><td>2</td><td><a href="ft2232h.html">FT2232HA</a></td></tr>
<tr><td>3600</td><td>0403:6048</td><td>4</td><td><a href="ft2232h.html">FT4232HA</a></td></tr>
</tbody></table>
</div>
<h3 id="ft8u232a-and-ft8u245a"><a class="header" href="#ft8u232a-and-ft8u245a">FT8U232A and FT8U245A</a></h3>
<p>These are the first-generation fixed-function D2xx devices. FT8U232A is a USB—UART bridge, while FT8U245A is a USB—FIFO bridge. They look exactly the same from the software perspective, and in fact may or may not be the same silicon.</p>
<p>They are configured by an optional external 93C46 (64×16-bit word) EEPROM. If no EEPROM is present, or the EEPROM is unprogrammed, the device will use a default configuration.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>FT8U232AM</td><td>32-pin MQFP</td></tr>
<tr><td>FT8U245AM</td><td>32-pin MQFP</td></tr>
</tbody></table>
</div>
<h3 id="ft232b-and-ft245b"><a class="header" href="#ft232b-and-ft245b">FT232B and FT245B</a></h3>
<p>These are a second-generation revision of FT8U2xxA. They are largely software-compatible, but introduce a few new features:</p>
<ul>
<li>configurable latency timer</li>
<li>bitbang mode</li>
<li>serial number descriptor</li>
<li>support for larger 93C56 (128×16) and 93C66 (256×16) EEPROMs in addition to 93C46</li>
</ul>
<p>They are mostly, but not completely pin compatible with FT8U2xxA in the QFP packages.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>FT232BM</td><td>32-pin LQFP</td></tr>
<tr><td>FT232BL</td><td>32-pin lead-free LQFP</td></tr>
<tr><td>FT232BQ</td><td>32-pin QFN</td></tr>
<tr><td>FT245BM</td><td>32-pin LQFP</td></tr>
<tr><td>FT245BL</td><td>32-pin lead-free LQFP</td></tr>
</tbody></table>
</div>
<h3 id="ft2232cdl"><a class="header" href="#ft2232cdl">FT2232C/D/L</a></h3>
<p>A third-generation D2xx device. This device features two largely-independent channels (called A and B), which can be independently configured through EEPROM in several modes:</p>
<ul>
<li>UART (like FT232B)</li>
<li>FIFO (like FT245B)</li>
<li>CPU FIFO (new mode, meant for use as a peripherial on an 8051-style MCU bus)</li>
<li>fast opto-isolated serial (custom serial protocol, optimised for low pin count and speed)</li>
</ul>
<p>In addition, the device can also dynamically switch either of the two channels into alternate modes:</p>
<ul>
<li>async bitbang mode: like FT232B/FT245B</li>
<li>MPSSE mode: implements a fast controller for SPI, JTAG, and similar protocols (channel A only)</li>
<li>sync bitbang mode: new, variation of the async bitbang mode</li>
<li>MCU bus: uses pins of both channels; makes the device capable of controlling an 8051-style MCU bus and driving MCU peripherials</li>
</ul>
<p>Like FT2xxB, the device can be configured by a 93C46/93C56/93C66 external EEPROM.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>what is</th></tr></thead><tbody>
<tr><td>FT2232C</td><td>48-pin LQFP</td><td>base version</td></tr>
<tr><td>FT2232L</td><td>48-pin lead-free LQFP</td><td>base version</td></tr>
<tr><td>FT2232D</td><td>48-pin lead-free LQFP</td><td>revised version</td></tr>
</tbody></table>
</div>
<h3 id="ft232rft245r"><a class="header" href="#ft232rft245r">FT232R/FT245R</a></h3>
<p>A fourth-generation D2xx device. The FT232R and FT245R are, in fact, the same chip, and it seems that they can be converted into one another via an EEPROM change. They are an enhanced version of FT2xxB, with the following new features:</p>
<ul>
<li>internal 32×32-bit EEPROM for configuration (instead of external 93C*), plus 8×32-bit factory-programmed area with unique per-chip ID
<ul>
<li>whether the device is FT232R or FT245R is stored in the user-programmable area and can be changed, though vendor tools go out of their way not to do so</li>
</ul>
</li>
<li>internal oscillator</li>
<li>configurable CBUS pins with multiple functions (FT232R only)</li>
<li>CBUS GPIO mode (allows putting individual CBUS pins under software control while continuing to use other pins for their normal UART purpose)</li>
<li>adds the synchronous bitbang mode (ported from FT2232C)</li>
</ul>
<p>The FT2xxRN is a variant of the device that makes the internal oscillator work with 3.3V VCC.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>FT232RL</td><td>28-pin TSSOP</td></tr>
<tr><td>FT232RQ</td><td>32-pin QFN</td></tr>
<tr><td>FT245RL</td><td>28-pin TSSOP</td></tr>
<tr><td>FT245RQ</td><td>32-pin QFN</td></tr>
<tr><td>FT232RNL</td><td>28-pin TSSOP</td></tr>
<tr><td>FT232RNQ</td><td>32-pin QFN</td></tr>
<tr><td>FT245RNL</td><td>28-pin TSSOP</td></tr>
<tr><td>FT245RNQ</td><td>32-pin QFN</td></tr>
</tbody></table>
</div>
<h3 id="ft2232h-and-ft4232h"><a class="header" href="#ft2232h-and-ft4232h">FT2232H and FT4232H</a></h3>
<p>Fifth-generation D2xx devices. FT2232H and FT4232H are the same silicon, and are differentiated by a fuse programmed in the factory.</p>
<p>FT2232H is an enhanced version of FT2232C, with the following new features:</p>
<ul>
<li>USB 2.0 high-speed interface</li>
<li>max UART speed bumped from 3Mbaud to 12Mbaud</li>
<li>max FIFO speed bumped from 1MB/s to 8MB/s</li>
<li>adds new synchronous FIFO submode, which further increases FIFO speed to 40MB/s</li>
<li>MPSSE mode is available on both channels</li>
<li>each channel now has 16 pins instead of 13 (additional pins can be used as GPIO in MPSSE mode)</li>
</ul>
<p>FT4232H is a variant with the following differences:</p>
<ul>
<li>four channels (A, B, C, D) instead of two, each of which includes 8 pins instead of 16</li>
<li>modes requiring more than 8 pins are not supported (FIFO, CPU FIFO, MCU bus)</li>
<li>fast opto-isolated serial mode is also not supported</li>
<li>only channels A and B support MPSSE (C and D are limitted to UART and bitbang)</li>
</ul>
<p>Later on, variants of these devices were made with USB-PD support. They have the same core functionality as the base version, but they require a 93C66 EEPROM to fit the extra configuration required for USB-PD.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>what</th></tr></thead><tbody>
<tr><td>FT2232HL</td><td>64-pin LQFP</td><td>base FT2232H</td></tr>
<tr><td>FT2232HQ</td><td>56-pin VQFN</td><td>base FT2232H</td></tr>
<tr><td>FT4232HL</td><td>64-pin LQFP</td><td>base FT4232H</td></tr>
<tr><td>FT4232HQ</td><td>56-pin VQFN</td><td>base FT4232H</td></tr>
<tr><td>FT2233HPQ</td><td>76-pin QFN</td><td>FT2232H with two USB-PD ports</td></tr>
<tr><td>FT4233HPQ</td><td>76-pin QFN</td><td>FT4232H with two USB-PD ports</td></tr>
<tr><td>FT2232HPQ</td><td>68-pin QFN</td><td>FT2232H with one USB-PD port</td></tr>
<tr><td>FT4232HPQ</td><td>68-pin QFN</td><td>FT4232H with one USB-PD port</td></tr>
<tr><td>FT2232HAQ</td><td>64-pin QFN</td><td>FT2232H automotive version</td></tr>
<tr><td>FT4232HAQ</td><td>64-pin QFN</td><td>FT4232H automotive version</td></tr>
</tbody></table>
</div>
<h3 id="ft232h"><a class="header" href="#ft232h">FT232H</a></h3>
<p>A single-channel variant of FT2232H, with some FT232R features merged in. Features include:</p>
<ul>
<li>USB 2.0 high-speed interface</li>
<li>a single channel, with 18 pins</li>
<li>supports all FT2232H modes except for the MCU bus mode (which would require more than 16 pins)</li>
<li>adds FT232R-style configurable CBUS pins, as well as the CBUS bitbang mode</li>
<li>continues to require external EEPROM; only 93C56 and 93C66 are supported</li>
<li>adds a new FT1248 mode</li>
</ul>
<p>Like FT2232H and FT4232H, this device also got USB-PD variants later on.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>what</th></tr></thead><tbody>
<tr><td>FT232HL</td><td>48-pin LQFP</td><td>base FT232H</td></tr>
<tr><td>FT232HQ</td><td>48-pin QFN</td><td>base FT232H</td></tr>
<tr><td>FT233HPQ</td><td>64-pin QFN</td><td>FT232H with two USB-PD ports</td></tr>
<tr><td>FT232HPQ</td><td>56-pin QFN</td><td>FT232H with one USB-PD port</td></tr>
</tbody></table>
</div>
<h3 id="ft-x-series"><a class="header" href="#ft-x-series">FT-X series</a></h3>
<p>A single-channel D2xx device. Essentially an enhanced version of FT232R, with the following changes:</p>
<ul>
<li>internal 2048-byte MTP memory for configuration, including some immutable factory pre-programmed data</li>
<li>the device comes in several variants; the variant is selected by the factory-programmed MTP area and cannot be changed
<ul>
<li>FT200X and FT201X: USB to I2C peripherial bridge</li>
<li>FT220X and FT221X: USB to FT1248 / SPI bridge</li>
<li>FT230X, FT231X, FT234X: USB to UART bridge (like FT232R)</li>
<li>FT240X: USB to FIFO bridge (like FT245R)</li>
</ul>
</li>
<li>adds battery charger detection</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>business end</th><th>business end pins</th></tr></thead><tbody>
<tr><td>FT200XD</td><td>10-pin DFN</td><td>I2C peripherial</td><td>2×I2C + 1×CBUS</td></tr>
<tr><td>FT201XS</td><td>16-pin SSOP</td><td>I2C peripherial</td><td>2×I2C + 6×CBUS</td></tr>
<tr><td>FT201XQ</td><td>16-pin QFN</td><td>I2C peripherial</td><td>2×I2C + 6×CBUS</td></tr>
<tr><td>FT220XS</td><td>16-pin SSOP</td><td>4-bit FT1248 or SPI</td><td>7×FT1248/SPI + 1×CBUS</td></tr>
<tr><td>FT220XQ</td><td>16-pin QFN</td><td>4-bit FT1248 or SPI</td><td>7×FT1248/SPI + 1×CBUS</td></tr>
<tr><td>FT221XS</td><td>20-pin SSOP</td><td>8-bit FT1248 or SPI</td><td>11×FT1248/SPI + 1×CBUS</td></tr>
<tr><td>FT221XQ</td><td>20-pin QFN</td><td>8-bit FT1248 or SPI</td><td>11×FT1248/SPI + 1×CBUS</td></tr>
<tr><td>FT230XS</td><td>16-pin SSOP</td><td>basic UART</td><td>4×UART + 4×CBUS</td></tr>
<tr><td>FT230XQ</td><td>16-pin QFN</td><td>basic UART</td><td>4×UART + 4×CBUS</td></tr>
<tr><td>FT231XS</td><td>20-pin SSOP</td><td>full UART</td><td>8×UART + 4×CBUS</td></tr>
<tr><td>FT231XQ</td><td>20-pin QFN</td><td>full UART</td><td>8×UART + 4×CBUS</td></tr>
<tr><td>FT234XD</td><td>12-pin DFN</td><td>basic UART</td><td>4×UART + 1×CBUS</td></tr>
<tr><td>FT240XS</td><td>24-pin SSOP</td><td>FIFO</td><td>13×FIFO + 2×CBUS</td></tr>
<tr><td>FT240XQ</td><td>24-pin QFN</td><td>FIFO</td><td>13×FIFO + 2×CBUS</td></tr>
</tbody></table>
</div>
<h3 id="ft4222h"><a class="header" href="#ft4222h">FT4222H</a></h3>
<p>The FT4222H is a high-speed USB to QSPI/I2C + GPIO bridge. Internally, it is based on an MCU (unknown, but likely FT32).</p>
<p>The device is configured using internal OTP memory.</p>
<p>The device has four channel configurations, selectable by two configuration pins:</p>
<div class="table-wrapper"><table><thead><tr><th>mode</th><th>channel count</th><th>channel 0</th><th>channel 1</th><th>channel 2</th><th>channel 3</th></tr></thead><tbody>
<tr><td>0</td><td>2</td><td>SPIC / SPIP / I2CC / I2CP</td><td>GPIO</td><td>-</td><td>-</td></tr>
<tr><td>1</td><td>4</td><td>SPIC (CS0)</td><td>SPIC (CS1)</td><td>SPIC (CS2)</td><td>GPIO</td></tr>
<tr><td>2</td><td>4</td><td>SPIC (CS0)</td><td>SPIC (CS1)</td><td>SPIC (CS2)</td><td>SPIC (CS3)</td></tr>
<tr><td>3</td><td>1</td><td>SPIC / SPIP / I2CC / I2CP</td><td>-</td><td>-</td><td>-</td></tr>
</tbody></table>
</div>
<p>The device has four modes, selected at runtime:</p>
<ul>
<li>SPIC: SPI controller; depending on channel configuration, can use up to four CS lines, and thus control 4 peripherials; every peripherial is controlled by a dedicated channel</li>
<li>SPIP: SPI peripherial (not available in modes 1 and 2)</li>
<li>I2CC: I2C controller (not available in modes 1 and 2)</li>
<li>I2CP: I2C peripherial (not available in modes 1 and 2)</li>
</ul>
<p>The device comes in 4 revisions, which differ in firmware version:</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>firmware</th></tr></thead><tbody>
<tr><td>FT4222HQ-A</td><td>32-pin VQFN</td><td>rev A</td></tr>
<tr><td>FT4222HQ-B</td><td>32-pin VQFN</td><td>rev B</td></tr>
<tr><td>FT4222HQ-C</td><td>32-pin VQFN</td><td>rev C</td></tr>
<tr><td>FT4222HQ-D</td><td>32-pin VQFN</td><td>rev D</td></tr>
</tbody></table>
</div>
<h2 id="d3xx-devices"><a class="header" href="#d3xx-devices">D3xx devices</a></h2>
<p>D3xx devices are USB super-speed peripherial devices that implement the D3xx protocol. There are several variants:</p>
<ul>
<li>FT600 and FT601: USB—FIFO bridge
<ul>
<li>FT600: up to 16-bit FIFO</li>
<li>FT601: up to 32-bit FIFO</li>
</ul>
</li>
<li>FT602: USB—FIFO bridge implementing the UVC protocol</li>
</ul>
<p>All of these devices are internally based on an FT32-based MCU.</p>
<div class="table-wrapper"><table><thead><tr><th>default VID:PID</th><th>device</th></tr></thead><tbody>
<tr><td>0403:601e</td><td>FT600</td></tr>
<tr><td>0403:601f</td><td>FT601</td></tr>
<tr><td>TODO</td><td>FT602</td></tr>
</tbody></table>
</div>
<h2 id="ft260"><a class="header" href="#ft260">FT260</a></h2>
<p>FT260 is a USB—UART/I2C bridge implementing the HID device class. It is internally based on an unknown MCU (FT32? FT51?). It can be configured using internal eFUSE memory or external EEPROM.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>default VID:PID</th><th>package</th></tr></thead><tbody>
<tr><td>FT260Q</td><td>0403:6030</td><td>28-pin WQFN</td></tr>
<tr><td>FT260S</td><td>0403:6030</td><td>28-pin TSSOP</td></tr>
</tbody></table>
</div>
<h2 id="ft12-series"><a class="header" href="#ft12-series">FT12 series</a></h2>
<p>FT12 series devices are, essentially, completely customizable USB peripherial devices meant to be controlled by an external MCU. The FT12 acts as a PHY and endpoint FIFO controller, while the MCU is supposed to implement all USB endpoint logic, including control requests.</p>
<p>Note that the internal VID:PID listed in the table is actually presented to the <em>MCU</em> as FT12's identification, not to the host. The actual USB VID:PID is provided by the MCU.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>max endpoints</th><th>MCU interface</th><th>internal VID:PID</th><th>package</th></tr></thead><tbody>
<tr><td>FT120T</td><td>6</td><td>MCU parallel bus</td><td>none</td><td>28-pin TSSOP</td></tr>
<tr><td>FT121T</td><td>16</td><td>SPI</td><td>0403:6018</td><td>16-pin TSSOP</td></tr>
<tr><td>FT121Q</td><td>16</td><td>SPI</td><td>0403:6018</td><td>16-pin QFN</td></tr>
<tr><td>FT122T</td><td>16</td><td>MCU parallel bus</td><td>0403:6018</td><td>28-pin TSSOP</td></tr>
<tr><td>FT122Q</td><td>16</td><td>MCU parallel bus</td><td>0403:6018</td><td>28-pin QFN</td></tr>
</tbody></table>
</div>
<h2 id="mcu-devices"><a class="header" href="#mcu-devices">MCU devices</a></h2>
<h3 id="ft8u100a"><a class="header" href="#ft8u100a">FT8U100A</a></h3>
<p>FT8U100A is an MCU based on an unknown 8-bit architecture (8051?). It implements a USB hub, with 1 upstream port and 7 physical downstream ports, as well as virtual downstream ports for internal devices. It also has a variety of peripherials, such as UART, PS/2 keyboard/mouse host, IrDA, I2C controller, and GPIO. It comes with ready-made firmware that can be used to expose these peripherials as USB devices (including SIO UART, the first device in the D2xx family).</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>FT8U100AX</td><td>100-pin PQFP</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>VID:PID</th><th>internal device</th></tr></thead><tbody>
<tr><td>0403:8370</td><td>USB hub</td></tr>
<tr><td>0403:8371</td><td>PS/2 keyboard and mouse</td></tr>
<tr><td>0403:8372</td><td>UART (D2xx protocol)</td></tr>
</tbody></table>
</div>
<p>TODO: list incomplete</p>
<h3 id="ft51"><a class="header" href="#ft51">FT51</a></h3>
<p>FT51 is an 8051-based MCU that has a programmable USB peripherial interface, as well as a USB hub. It is used in the UMFTPD3A and UMFT4222PROG boards. It comes in several variants, all of which are the same silicon and only differ in the number of pins:</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>GPIO</th></tr></thead><tbody>
<tr><td>FT51AQ</td><td>48-pin QFN</td><td>16×DIO + 16×AIO</td></tr>
<tr><td>FT51AL</td><td>44-pin LQFP</td><td>16×DIO + 16×AIO</td></tr>
<tr><td>FT51BQ</td><td>32-pin QFN</td><td>16×DIO + 8×AIO</td></tr>
<tr><td>FT51CS</td><td>28-pin SSOP</td><td>12×DIO + 8×AIO</td></tr>
</tbody></table>
</div>
<h3 id="ft900-series"><a class="header" href="#ft900-series">FT900 series</a></h3>
<p>FT900 is an MCU based on FTDI's custom FT32 RISC-like architecture. It comes in several variants, all of which are actually the same silicon:</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>ethernet</th><th>CAN</th><th>GPIO pins</th><th>SD host</th><th>SPI peripherial</th><th>I2C</th><th>I2S</th><th>package</th></tr></thead><tbody>
<tr><td>FT900Q</td><td>yes</td><td>yes</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin QFN</td></tr>
<tr><td>FT900L</td><td>yes</td><td>yes</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin LQFP</td></tr>
<tr><td>FT901Q</td><td>yes</td><td>no</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin QFN</td></tr>
<tr><td>FT901L</td><td>yes</td><td>no</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin LQFP</td></tr>
<tr><td>FT902Q</td><td>no</td><td>yes</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin QFN</td></tr>
<tr><td>FT902L</td><td>no</td><td>yes</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin LQFP</td></tr>
<tr><td>FT903Q</td><td>no</td><td>no</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin QFN</td></tr>
<tr><td>FT903L</td><td>no</td><td>no</td><td>66</td><td>yes</td><td>2</td><td>2</td><td>yes</td><td>100-pin LQFP</td></tr>
<tr><td>FT905Q</td><td>yes</td><td>yes</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>76-pin QFN</td></tr>
<tr><td>FT905L</td><td>yes</td><td>yes</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>80-pin LQFP</td></tr>
<tr><td>FT906Q</td><td>yes</td><td>no</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>76-pin QFN</td></tr>
<tr><td>FT906L</td><td>yes</td><td>no</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>80-pin LQFP</td></tr>
<tr><td>FT907Q</td><td>no</td><td>yes</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>76-pin QFN</td></tr>
<tr><td>FT907L</td><td>no</td><td>yes</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>80-pin LQFP</td></tr>
<tr><td>FT908Q</td><td>no</td><td>no</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>76-pin QFN</td></tr>
<tr><td>FT908L</td><td>no</td><td>no</td><td>44</td><td>no</td><td>1</td><td>1</td><td>no</td><td>80-pin LQFP</td></tr>
</tbody></table>
</div>
<p>FT900 comes with (device-side) libraries that can implement the D2xx protocol in software.</p>
<h3 id="ft930-series"><a class="header" href="#ft930-series">FT930 series</a></h3>
<p>FT930 is an MCU based on FT32B, a revision of the FT32 architecture used in the FT900 series. It comes in several variants, all of which are actually the same silicon:</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>DAC</th><th>ADC</th><th>PWM</th><th>SD host</th><th>RTC</th><th>UART</th><th>GPIO</th><th>pins</th></tr></thead><tbody>
<tr><td>FT930Q</td><td>×2</td><td>×3</td><td>×8</td><td>yes</td><td>yes</td><td>×4</td><td>40</td><td>68-pin QFN</td></tr>
<tr><td>FT931Q</td><td>×2</td><td>×3</td><td>×4</td><td>yes</td><td>yes</td><td>×2</td><td>28</td><td>56-pin QFN</td></tr>
<tr><td>FT932Q</td><td>×2</td><td>×3</td><td>×4</td><td>yes</td><td>no</td><td>×2</td><td>24</td><td>48-pin QFN</td></tr>
<tr><td>FT933Q</td><td>no</td><td>×2</td><td>×4</td><td>no</td><td>no</td><td>×2</td><td>16</td><td>48-pin QFN</td></tr>
</tbody></table>
</div>
<p>In addition to the main FT32B core that is advertised in the datasheet, FT930 also contains a secondary MCU (unknown architecture, but likely also FT32). The "hardware D2xx engine" advertised in the datasheet is actually implemented in software on the other MCU core.</p>
<h3 id="vnc1"><a class="header" href="#vnc1">VNC1</a></h3>
<p>VNC1, also known as Vinculum, is an MCU with USB host and peripherial interfaces. It is based on a custom 8-bit Harvard architecture, known as FT8.  It has a cute 32-bit integer numeric coprocessor for complex arithmetic tasks such as "handling the FAT filesystem".</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>VNC1L</td><td>48-pin LQFP</td></tr>
</tbody></table>
</div>
<h3 id="vnc2"><a class="header" href="#vnc2">VNC2</a></h3>
<p>VNC2, also known as Vinculum-II, is an MCU with USB host and peripherial interfaces. It is based on a custom Harvard 16-bit architecture, known as FT16.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>GPIO</th></tr></thead><tbody>
<tr><td>VNC2-48L</td><td>48-pin LQFP</td><td>28</td></tr>
<tr><td>VNC2-48Q</td><td>48-pin QFN</td><td>28</td></tr>
<tr><td>VNC2-32L</td><td>32-pin LQFP</td><td>12</td></tr>
<tr><td>VNC2-32Q</td><td>32-pin QFN</td><td>12</td></tr>
</tbody></table>
</div>
<h4 id="ft311-and-ft312"><a class="header" href="#ft311-and-ft312">FT311 and FT312</a></h4>
<p>FT311 and FT312 are Android Open Accessory host devices. They are USB full-speed hosts that accept a single peripherial that should support the AOA protocol. They will then expose UART or other interface to the Android device.</p>
<p>The device has internal flash memory which stores, among other things, the descriptor strings presented to the Android device. It can be modified via an FTDI null-modem cable and a configuration utility.</p>
<p>Both of these devices are actually just VNC2 chips with preprogrammed firmware.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th><th>interfaces</th></tr></thead><tbody>
<tr><td>FT311D-32Q1C</td><td>32-pin QFN</td><td>one of: UART, GPIO, PWM, I2C controller, SPI controller, SPI peripherial</td></tr>
<tr><td>FT311D-32L1C</td><td>32-pin LQFP</td><td>one of: UART, GPIO, PWM, I2C controller, SPI controller, SPI peripherial</td></tr>
<tr><td>FT312D-32Q1C</td><td>32-pin QFN</td><td>UART</td></tr>
<tr><td>FT312D-32L1C</td><td>32-pin LQFP</td><td>UART</td></tr>
</tbody></table>
</div>
<h2 id="ft313"><a class="header" href="#ft313">FT313</a></h2>
<p>FT313 is an EHCI controller meant to be connected as a peripherial to 8051-style MCU bus.  It has 24kiB of internal buffer memory and DMA support.</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>FT313HQ</td><td>64-pin QFN</td></tr>
<tr><td>FT313HL</td><td>64-pin LQFP</td></tr>
<tr><td>FT313HP</td><td>64-pin TQFP</td></tr>
</tbody></table>
</div>
<h2 id="eve-display-controllers"><a class="header" href="#eve-display-controllers">EVE display controllers</a></h2>
<p>EVE (Embedded Video Engine) aka FT8xx aka BT8xx is a series of display controllers.  They are meant to be driven by an external MCU, and provide parallel or LVDS video output (and, in some cases, input), audio output, and a resistive or capacitive touch controller.</p>
<h3 id="eve-aka-ft80x"><a class="header" href="#eve-aka-ft80x">EVE aka FT80x</a></h3>
<p>The first generation of EVE.  Both chips are the same silicon.  It features:</p>
<ul>
<li>SPI peripherial or I2C peripherial interface exposing internal RAM and registers, meant to be controlled by the MCU host</li>
<li>256kiB of internal RAM</li>
<li>parallel 18-bit RGB video output, up to 480×272 resolution</li>
<li>display list based graphics engine driving the video output
<ul>
<li>basic rendering features</li>
<li>JPEG decode</li>
<li>zlib decompression</li>
<li>ROM and RAM fonts</li>
</ul>
</li>
<li>backlight control</li>
<li>one-channel PWM audio output, playing PCM audio or predefined sound effects from ROM wave table</li>
<li>touch controller
<ul>
<li>resistive version: directly controls the touchscreen via analog pins</li>
<li>capacitive version: has an I2C controller interface meant to be connected to the capacitive touchscreen</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>touch interface</th><th>package</th></tr></thead><tbody>
<tr><td>FT800Q</td><td>resistive</td><td>48-pin VQFN</td></tr>
<tr><td>FT801Q</td><td>capacitive</td><td>48-pin VQFN</td></tr>
</tbody></table>
</div>
<h3 id="eve2-aka-ft81x-and-bt88x"><a class="header" href="#eve2-aka-ft81x-and-bt88x">EVE2 aka FT81x and BT88x</a></h3>
<p>The second generation of EVE.  FT81x has the following differences from FT80x:</p>
<ul>
<li>MCU interface is SPI or QSPI peripherial</li>
<li>1MiB of internal RAM</li>
<li>different memory map</li>
<li>video output supports up to 800×600 resolution</li>
<li>video output is 24-bit instead of 18-bit (on FT812 and FT813 only)</li>
</ul>
<p>The BT88x is a smaller variant of EVE2.  It has the following differences from FT81x:</p>
<ul>
<li>only 256kiB of internal RAM</li>
<li>video output resolution is limitted to 131072 pixels total</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>video output</th><th>touch interface</th><th>internal RAM</th><th>package</th></tr></thead><tbody>
<tr><td>FT810Q</td><td>18-bit RGB</td><td>resistive</td><td>1MiB</td><td>48-pin VQFN</td></tr>
<tr><td>FT811Q</td><td>18-bit RGB</td><td>capacitive</td><td>1MiB</td><td>48-pin VQFN</td></tr>
<tr><td>FT812Q</td><td>24-bit RGB</td><td>resistive</td><td>1MiB</td><td>56-pin VQFN</td></tr>
<tr><td>FT813Q</td><td>24-bit RGB</td><td>capacitive</td><td>1MiB</td><td>56-pin VQFN</td></tr>
<tr><td>BT880Q</td><td>18-bit RGB</td><td>resistive</td><td>256kiB</td><td>48-pin VQFN</td></tr>
<tr><td>BT881Q</td><td>18-bit RGB</td><td>capacitive</td><td>256kiB</td><td>48-pin VQFN</td></tr>
<tr><td>BT882Q</td><td>24-bit RGB</td><td>resistive</td><td>256kiB</td><td>56-pin VQFN</td></tr>
<tr><td>BT883Q</td><td>24-bit RGB</td><td>capacitive</td><td>256kiB</td><td>56-pin VQFN</td></tr>
</tbody></table>
</div>
<p>All of the FT81x devices are the same silicon.  FT810 and FT811 are pin-compatible with FT800 and FT801.</p>
<p>Likewise, all BT88x devices are the same silicon.  They are pin-compatible with their corresponding FT81x devices.</p>
<h3 id="eve3-aka-bt815bt816"><a class="header" href="#eve3-aka-bt815bt816">EVE3 aka BT815/BT816</a></h3>
<p>The third generation of EVE.  It has switched to the BT (Bridgetek) device name prefix.  It has the following differences from EVE2:</p>
<ul>
<li>added QSPI controller interface meant for connecting an external flash chip with preprogrammed graphics or audio data</li>
<li>sigma-delta audio output instead of PWM</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>touch interface</th><th>package</th></tr></thead><tbody>
<tr><td>BT815Q</td><td>capacitive</td><td>64-pin VQFN</td></tr>
<tr><td>BT816Q</td><td>resistive</td><td>64-pin VQFN</td></tr>
</tbody></table>
</div>
<p>Both BT815 and BT816 are the same silicon.</p>
<h3 id="eve4-aka-bt817bt818"><a class="header" href="#eve4-aka-bt817bt818">EVE4 aka BT817/BT818</a></h3>
<p>The fourth generation of EVE.  It has the following differences from EVE3:</p>
<ul>
<li>video output supports up to 1920×480, 1440×540, or 1280×800 resolution</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>touch interface</th><th>package</th></tr></thead><tbody>
<tr><td>BT817Q</td><td>capacitive</td><td>64-pin VQFN</td></tr>
<tr><td>BT817AQ</td><td>capacitive</td><td>64-pin VQFN</td></tr>
<tr><td>BT818Q</td><td>resistive</td><td>64-pin VQFN</td></tr>
</tbody></table>
</div>
<p>BT817A is an automotive variant of BT817.</p>
<p>All EVE4 devices are the same silicon.</p>
<h3 id="eve5-aka-bt820"><a class="header" href="#eve5-aka-bt820">EVE5 aka BT820</a></h3>
<p>The fifth generation of EVE, with major changes.  It has the following features:</p>
<ul>
<li>QSPI peripherial interface for the MCU host</li>
<li>QSPI controller interface for flash</li>
<li>memory controller for DDR3/DDR3L/LPDDR2 working memory</li>
<li>SD card host interface</li>
<li>dual-channel FPD-link video output
<ul>
<li>with backlight control</li>
</ul>
</li>
<li>dual-channel FPD-link video input</li>
<li>I2C controller interface for capacitive touch</li>
<li>audio output through stereo delta-sigma or I2S</li>
<li>16 GPIO pins</li>
<li>display list based graphics engine
<ul>
<li>PNG and JPG decode support</li>
<li>deflate decode support</li>
<li>ROM and RAM fonts</li>
</ul>
</li>
<li>render engine for memory-to-memory drawing
<ul>
<li>ASTC decode support</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>package</th></tr></thead><tbody>
<tr><td>BT820B</td><td>329-pin BGA</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="d2xx-protocol"><a class="header" href="#d2xx-protocol">D2xx protocol</a></h1>
<p>D2xx is the name of protocol used by most FTDI USB devices.  It was originally made for the UART function of the FT8U100A, and remains quite UART-oriented.  However, FTDI has reused it for all kinds of stream-based interfaces.</p>
<h2 id="channels-and-interfaces"><a class="header" href="#channels-and-interfaces">Channels and interfaces</a></h2>
<p>A D2xx device can have one or more channels.  A channel is, at the core, a bidirectional byte-oriented stream of data.</p>
<p>Channels are often identified by single letters, in order (A, B, C, D, ...).</p>
<p>Each channel is exposed as a separate USB interface.  Each interface has two bulk endpoints: IN and OUT.  In addition, a channel also makes use of D2xx-specific control requests on the default config pipe (endpoint 0).</p>
<p>Some devices have an undocumented option to use isochronous endpoints instead of bulk endpoints.  That options is undoubtedly broken in some completely hilarious ways.</p>
<h2 id="identifying-a-d2xx-device"><a class="header" href="#identifying-a-d2xx-device">Identifying a D2xx device</a></h2>
<p>Since all D2xx devices can have custom VIDs and PIDs programmed, there is no sure-fire way to identify a USB device as a D2xx device — you need to know what VID:PID you are looking for.  However, there are some predefined VID:PID combinations that will be used by default.  They are listed in the table on the <a href="devices.html#d2xx-devices">devices page</a>.</p>
<p>As you can see, FTDI used to reuse its VID:PID combinations for groups of similar devices for some time, but then decided to just start assigning new IDs for every new device.</p>
<p>Once something is known to be a FTD2xx device, further identification can be obtained from the <code>bcdDevice</code> field of USB descriptor.  The <code>bcdDevice</code> values are likewise listed on the <a href="devices.html#d2xx-devices">devices page</a>.  It is not clear whether the <code>bcdDevice</code> field may be overriden via EEPROM.</p>
<p>Even putting VID:PID and <code>bcdDevice</code> together, it is still not always possible to uniquely identify the device.  Usually, one can just live with the uncertainty.  However, there are some more checks that can be done for further identification:</p>
<ul>
<li>FT8U2xxA and FT2xxB can be told apart by attempting the <code>GET_LATENCY_TIMER</code> request — a failure implies A-series device, while a success implies B-series device</li>
<li>FT232R and FT245R can be told apart by a field in the internal EEPROM, which the vendor claims to not be modifiable by the user</li>
<li>likewise, FT-X series devices can be told apart to some extent by another EEPROM field</li>
</ul>
<h2 id="stream-protocol"><a class="header" href="#stream-protocol">Stream protocol</a></h2>
<p>Note: FT2xxR devices have configurable <code>wMaxPacketSize</code> field in the bulk endpoint descriptors.  There are devices in the wild where people have programmed the (invalid) value of 0 in that field.  In case a device is encountered with such value, it should be overriden in the driver to 64 bytes.</p>
<h3 id="in-endpoint"><a class="header" href="#in-endpoint">IN endpoint</a></h3>
<p>The IN endpoint of a channel is used to transfer byte stream data from the device to the user.  It involves a framing protocol: every packet transferred on the endpoint includes a header with modem and line status.  Packets are always at least 2 bytes long.  The packet format is as follows:</p>
<ul>
<li>byte 0: modem status (shows the most recent state of the modem status input pins)
<ul>
<li>bit 0: always 1?</li>
<li>bit 1: always 0?</li>
<li>bit 2: always 0?</li>
<li>bit 3: always 0?</li>
<li>TODO: allegedly high-speed devices have 0010 in low bits?</li>
<li>bit 4: CTS</li>
<li>bit 5: DSR</li>
<li>bit 6: RI</li>
<li>bit 7: DCD</li>
</ul>
</li>
<li>byte 1: line status
<ul>
<li>bit 0: data ready (???)</li>
<li>bit 1: overrun error (device received data on the business end when there was no more space in IN endpoint FIFO)</li>
<li>bit 2: parity error</li>
<li>bit 3: framing error</li>
<li>bit 4: break interrupt</li>
<li>bit 5: TX holding register (???)</li>
<li>bit 6: TX (OUT endpoint) FIFO is empty</li>
<li>bit 7: FIFO error (???)</li>
</ul>
</li>
<li>bytes 2 and up (if any): actual stream data</li>
</ul>
<p>As can be seen, the protocol is very UART-oriented.  The modem and line status bytes are present even for D2xx devices that have nothing to do with UART, though they are mostly dummied out in that case.  The TX FIFO empty bit is, however, generally useful.</p>
<p>TODO: kernel driver alleges that parity/framing errors are always associated with the last byte in the packet. Check this.</p>
<p>To avoid excessive load on the host, the device doesn't always transmit packets on the IN endpoint as soon as data is available.  Instead, the device will send a packet in the following circumstances:</p>
<ul>
<li>a full-sized packet has been filled</li>
<li>a special "event" character has been received (if enabled by driver)</li>
<li>data is available and the latency timer has expired
<ul>
<li>on FT8U2xxA (and FT8U100A?), the latency timer is always 16ms</li>
<li>on newer devices, the default latency timer is 16ms, but it can be configured to any value between 2ms and 255ms</li>
</ul>
</li>
<li>TODO: line errors / modem status changes too? kernel alleges device will send an update packet every 40ms even with no activity</li>
</ul>
<h3 id="out-endpoint"><a class="header" href="#out-endpoint">OUT endpoint</a></h3>
<p>There are two variants of the protocol with respect to OUT endpoint handling.</p>
<p>The original variant is present on the FT8U100A only.  In this variant, every OUT endpoint packet has to be prefixed with a header.  The packet then has the following format:</p>
<ul>
<li>byte 0: header
<ul>
<li>bit 0: must be 1</li>
<li>bit 1: must be 0</li>
<li>bits 2-7: length of payload (ie. length of packet, not including the header byte)</li>
</ul>
</li>
<li>bytes 1 and up: actual stream data</li>
</ul>
<p>Since the header is completely useless, it has been done away with in later devices.  In every device other than FT8U100A, the OUT endpoint is completely headerless and packets contain just the raw stream data.</p>
<h2 id="control-requests"><a class="header" href="#control-requests">Control requests</a></h2>
<p>The protocol includes the following control requests:</p>
<div class="table-wrapper"><table><thead><tr><th>request</th><th><code>bmRequestType</code></th><th><code>bRequest</code></th><th><code>wValue</code></th><th><code>wIndex</code></th><th>data</th></tr></thead><tbody>
<tr><td><code>RESET</code></td><td><code>0x40</code></td><td><code>0x00</code></td><td>reset kind</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_MODEM_CTRL</code></td><td><code>0x40</code></td><td><code>0x01</code></td><td>DTR + RTS state</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_FLOW_CTRL</code></td><td><code>0x40</code></td><td><code>0x02</code></td><td>XON / XOFF chars</td><td>channel + mode</td><td>-</td></tr>
<tr><td><code>SET_BAUD_RATE</code></td><td><code>0x40</code></td><td><code>0x03</code></td><td>divisor low bits</td><td>channel + divisor high bits</td><td>-</td></tr>
<tr><td><code>SET_DATA_CHARACTERISTICS</code></td><td><code>0x40</code></td><td><code>0x04</code></td><td>data format + break state</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_MODEM_STATUS</code></td><td><code>0xc0</code></td><td><code>0x05</code></td><td>0</td><td>channel</td><td>2 bytes</td></tr>
<tr><td><code>SET_EVENT_CHAR</code></td><td><code>0x40</code></td><td><code>0x06</code></td><td>event char + enable</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_ERROR_CHAR</code></td><td><code>0x40</code></td><td><code>0x07</code></td><td>error char + enable</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_LATENCY_TIMER</code></td><td><code>0x40</code></td><td><code>0x09</code></td><td>latency timer</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_LATENCY_TIMER</code></td><td><code>0xc0</code></td><td><code>0x0a</code></td><td>0</td><td>channel</td><td>1 byte</td></tr>
<tr><td><code>SET_BITMODE</code></td><td><code>0x40</code></td><td><code>0x0b</code></td><td>bit mode + output mask</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_PIN_STATE</code></td><td><code>0xc0</code></td><td><code>0x0c</code></td><td>0</td><td>channel</td><td>1 byte</td></tr>
<tr><td><code>VENDOR_CMD_GET</code></td><td><code>0xc0</code></td><td><code>0x20</code></td><td>request</td><td>channel</td><td>up to 0x80 bytes</td></tr>
<tr><td><code>VENDOR_CMD_SET</code></td><td><code>0x40</code></td><td><code>0x21</code></td><td>request + data</td><td>channel</td><td>up to 0x80 bytes</td></tr>
<tr><td><code>READ_EEPROM</code></td><td><code>0xc0</code></td><td><code>0x90</code></td><td>0</td><td>word address</td><td>2 bytes</td></tr>
<tr><td><code>WRITE_EEPROM</code></td><td><code>0x40</code></td><td><code>0x91</code></td><td>word value</td><td>word address</td><td>-</td></tr>
<tr><td><code>ERASE_EEPROM</code></td><td><code>0x40</code></td><td><code>0x92</code></td><td>0</td><td>0</td><td>-</td></tr>
</tbody></table>
</div>
<p>Most control requests operate on a channel.  The channel is specified as follows:</p>
<ul>
<li>for single-channel devices: channel is 0</li>
<li>for multi-channel devices: the channel indices start at 1 (ie. channel number in control request is USB interface index + 1)
<ul>
<li>TODO: allegedly, specifying 0 means "all channels"?</li>
</ul>
</li>
</ul>
<p>The channel is usually stuffed directly into <code>wIndex</code>.  However, there are variations to keep you on your toes.</p>
<h3 id="reset"><a class="header" href="#reset"><code>RESET</code></a></h3>
<p>Resets the device or purges IN/OUT endpoint buffers on device.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x00</code></li>
<li><code>wValue</code>: kind of reset to perform
<ul>
<li>0: reset the serial engine
<ul>
<li>purge both IN and OUT endpoints</li>
<li>disable event char and set it to <code>0x0d</code> (<code>'\r'</code>)</li>
<li>disable flow control</li>
<li>clear DTR and RTS</li>
</ul>
</li>
<li>1: purge OUT endpoint (nuke all buffered data)</li>
<li>2: purge IN endpoint</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>TODO: determine <em>exactly</em> what the reset actually resets; the above list is according to the kernel sources.</p>
<p>TODO: libftd2xx seems to always send resets with <code>wIndex</code> set to 0; is this a bug?</p>
<h3 id="set_modem_ctrl"><a class="header" href="#set_modem_ctrl"><code>SET_MODEM_CTRL</code></a></h3>
<p>Changes the state of DTR and RTS lines.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op in non-UART modes)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x01</code></li>
<li><code>wValue</code>:
<ul>
<li>bit 0: new DTR value</li>
<li>bit 1: new RTS value</li>
<li>bit 8: change DTR (if not set, DTR will be unchanged)</li>
<li>bit 9: change RTS</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_flow_ctrl"><a class="header" href="#set_flow_ctrl"><code>SET_FLOW_CTRL</code></a></h3>
<p>Changes hardware flow control mode.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op in non-UART modes)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x02</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: XON character</li>
<li>bits 8-15: XOFF character</li>
</ul>
</li>
<li><code>wIndex</code>:
<ul>
<li>bits 0-7: channel</li>
<li>bit 8: enable RTS/CTS flow control</li>
<li>bit 9: enable DTR/DSR flow control</li>
<li>bit 10: enable XON/XOFF flow control</li>
</ul>
</li>
</ul>
<p>TODO: make double-sure of <code>wIndex</code> encoding</p>
<p>TODO: check if XON/XOFF is applicable to eg. FIFO mode</p>
<h3 id="set_baud_rate"><a class="header" href="#set_baud_rate"><code>SET_BAUD_RATE</code></a></h3>
<p>Sets the baud rate, and also the clock for bitbang and MPSSE modes.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op on MCU-based ones)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x03</code></li>
<li><code>wValue</code>: bits 0-15 of the divisor value</li>
<li><code>wIndex</code>:
<ul>
<li>for single-channel device:
<ul>
<li>bits 0-1: bits 16-17 of the divisor</li>
</ul>
</li>
<li>for multi-channel device:
<ul>
<li>bits 0-7: channel</li>
<li>bits 8-9: bits 16-17 of the divisor</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The format of the divisor varies depending on the exact device.</p>
<h4 id="ft8u100a-1"><a class="header" href="#ft8u100a-1">FT8U100A</a></h4>
<p>For FT8U100A, the divisor is an enum, selecting the baud rate from the following fixed list:</p>
<ul>
<li>0: 300 baud</li>
<li>1: 600</li>
<li>2: 1200</li>
<li>3: 2400</li>
<li>4: 4800</li>
<li>5: 9600</li>
<li>6: 19200</li>
<li>7: 38400</li>
<li>8: 57600</li>
<li>9: 115200</li>
</ul>
<h4 id="ft8u232a-ft8u245a"><a class="header" href="#ft8u232a-ft8u245a">FT8U232A, FT8U245A</a></h4>
<p>These devices run on 48MHz base clock.  The base clock is divided by a fractional divisor to obtain the channel clock.  The channel clock is then further divided by 16 to obtain the baud rate.</p>
<p>The divisor is encoded into a 16-bit number as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special case below)</li>
<li>bits 14-15: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
</ul>
</li>
</ul>
<p>There is also a special divisor with dedicated encoding:</p>
<ul>
<li><code>0x0000</code> encodes a special divisor of 1 (corresponding to 3000000 baud rate)</li>
</ul>
<h4 id="ft232b-ft245b-ft232r-ft245r-ft2232cdl-ft-x-series"><a class="header" href="#ft232b-ft245b-ft232r-ft245r-ft2232cdl-ft-x-series">FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT-X series</a></h4>
<p>These devices are similar to FT8U2xxA, with minor extensions.  The encoding scheme is backwards-compatible.</p>
<p>The divisor is encoded into a 17-bit number (with top bit overflowing into the <code>wIndex</code> field) as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special cases below)</li>
<li>bits 14-16: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
<li>4: .375</li>
<li>5: .675</li>
<li>6: .75</li>
<li>7: .875</li>
</ul>
</li>
</ul>
<p>There are also two special divisors with dedicated encoding:</p>
<ul>
<li><code>0x0000</code> encodes a special divisor of 1 (corresponding to 3000000 baud rate)</li>
<li><code>0x0001</code> encodes a special divisor of 1.5 (corresponding to 2000000 baud rate)</li>
</ul>
<p>In addition to providing the UART baud rate, the channel clock (not divided by 16) is also used for other modes such as bitbang and MPSSE.</p>
<h4 id="ft2232h-ft4232h-ft232h-and-all-their-variants"><a class="header" href="#ft2232h-ft4232h-ft232h-and-all-their-variants">FT2232H, FT4232H, FT232H (and all their variants)</a></h4>
<p>These devices are USB high-speed peripherials, and support a higher baud rate and channel clock range.  The base clock of the device is 120MHz.  The divisor encoding is an extension of the one used in FT232B, and is backwards compatible.</p>
<p>The divisor is encoded into an 18-bit number (with top two bits overflowing into the <code>wIndex</code> field) as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special cases below)</li>
<li>bits 14-16: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
<li>4: .375</li>
<li>5: .675</li>
<li>6: .75</li>
<li>7: .875</li>
</ul>
</li>
<li>bit 17: divisor and UART mode
<ul>
<li>0: low-speed, FT232B compatible:
<ul>
<li>base 120MHz clock is pre-divided by 2.5 into a 48MHz clock before being put through the divisor</li>
<li>baud rate is channel clock divided by 16</li>
</ul>
</li>
<li>1: high-speed:
<ul>
<li>base 120MHz clock is fed directly into the divisor</li>
<li>baud rate is channel clock divided by 10</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>There are also two special divisors with dedicated encoding:</p>
<ul>
<li><code>0x00000</code> or <code>0x20000</code> encodes a special divisor of 1 (corresponding to low-speed 3000000 or high-speed 12000000 baud rate, respectively)</li>
<li><code>0x00001</code> or <code>0x20001</code> encodes a special divisor of 1.5 (corresponding to low-speed 2000000 or high-speed 8000000 baud rate, respectively)</li>
</ul>
<p>In addition to providing the UART baud rate, the channel clock (not divided by 10 or 16) is also used for other modes such as bitbang and MPSSE.</p>
<p>Note that, while the new high-speed divisor mode is usually preferable due to more precision, it cannot represent some of the lowest baud rates (600 baud and below). The low-speed mode should be used for those.</p>
<h3 id="set_data_characteristics"><a class="header" href="#set_data_characteristics"><code>SET_DATA_CHARACTERISTICS</code></a></h3>
<p>Sets the UART data format and break state.</p>
<ul>
<li>applicable to: all D2xx devices (but will be a no-op in non-UART mode)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x04</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: number of data bits (7-8; allegedly FT8U100A can also do 5-6)</li>
<li>bits 8-10: parity mode
<ul>
<li>0: none</li>
<li>1: odd</li>
<li>2: even</li>
<li>3: mark</li>
<li>4: space</li>
</ul>
</li>
<li>bits 11-13: stop bits
<ul>
<li>0: 1 bit</li>
<li>1: 1.5 bits (support status unclear)</li>
<li>2: 2 bits</li>
</ul>
</li>
<li>bit 14: transmitter in break state if set</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="get_modem_status"><a class="header" href="#get_modem_status"><code>GET_MODEM_STATUS</code></a></h3>
<p>Returns current modem status and line status.  This is the same information that is transmitted in the packet header bytes on the IN endpoint.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x05</code></li>
<li><code>wValue</code>: <code>0</code></li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: <code>2</code></li>
<li>data:
<ul>
<li>byte 0: modem status (shows the most recent state of the modem status input pins)
<ul>
<li>bit 0: always 1?</li>
<li>bit 1: always 0?</li>
<li>bit 2: always 0?</li>
<li>bit 3: always 0?</li>
<li>TODO: allegedly high-speed devices have 0010 in low bits?</li>
<li>bit 4: CTS</li>
<li>bit 5: DSR</li>
<li>bit 6: RI</li>
<li>bit 7: DCD</li>
</ul>
</li>
<li>byte 1: line status
<ul>
<li>bit 0: data ready (???)</li>
<li>bit 1: overrun error (device received data on the business end when there was no more space in IN endpoint FIFO)</li>
<li>bit 2: parity error</li>
<li>bit 3: framing error</li>
<li>bit 4: break interrupt</li>
<li>bit 5: TX holding register (???)</li>
<li>bit 6: TX (OUT endpoint) FIFO is empty</li>
<li>bit 7: FIFO error (???)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TODO: allegedly FT8U100A only returns the first byte?</p>
<h3 id="set_event_char"><a class="header" href="#set_event_char"><code>SET_EVENT_CHAR</code></a></h3>
<p>Sets the special "event" character.  Whenever a matching byte is received on the business end of the device, a packet will be sent on the IN endpoint immediately, instead of waiting for the buffer to fill completely or for the latency timer to expire.  This can be eg. set to <code>0x0d</code> (CR) to immediately present received lines to the host.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x06</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: event character</li>
<li>bit 8: event character enable (if unset, no event character processing is done)</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_error_char"><a class="header" href="#set_error_char"><code>SET_ERROR_CHAR</code></a></h3>
<p>Sets the special "error" character that will be inserted into the receive FIFO in place of parity and framing errors.</p>
<ul>
<li>applicable to: all D2xx devices (but will be a no-op in non-UART mode)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x07</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: error character</li>
<li>bit 8: error character enable (if unset, parity and framing errors do not insert anything into the FIFO)</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_latency_timer"><a class="header" href="#set_latency_timer"><code>SET_LATENCY_TIMER</code></a></h3>
<p>Sets the latency timer (see IN endpoint description).</p>
<ul>
<li>applicable to: everything except FT8U100A, FT8U232A, FT8U245A</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x09</code></li>
<li><code>wValue</code>: latency timer, in units of 1ms (2 to 255)</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>Note: on FT232R and FT245R this command is also used as EEPROM write unlock. The latency timer has to be set to <code>0x77</code> to enable EEPROM writes.  Otherwise, the write commands get ignored.</p>
<h3 id="get_latency_timer"><a class="header" href="#get_latency_timer"><code>GET_LATENCY_TIMER</code></a></h3>
<p>Reads back the latency timer (see IN endpoint description).  Also useful for telling FT8U2xxA and FT2xxB apart.</p>
<ul>
<li>applicable to: everything except FT8U100A, FT8U232A, FT8U245A</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x0a</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: 1</li>
<li>data: latency timer (1 byte)</li>
</ul>
<h3 id="set_bitmode"><a class="header" href="#set_bitmode"><code>SET_BITMODE</code></a></h3>
<p>Sets a special mode on the channel, overriding whatever base mode it has.</p>
<ul>
<li>applicable to: FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series
<ul>
<li>async bitbang: all of the above devices</li>
<li>MPSSE: FT2232[CDL] (channel A only), FT2232H, FT4232H (channel A and B only), FT232H</li>
<li>sync bitbang: FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li>MCU host bus: FT2232[CDL], FT2232H</li>
<li>fast opto-isolated serial: FT2232[CDL], FT2232H, FT232H</li>
<li>CBUS bit-bang: FT232R, FT232H, FT-X series</li>
<li>synchronous 245-style FIFO: FT2232H, FT232H</li>
<li>FT1248: FT232H maybe?!?</li>
</ul>
</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x09</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: depends on mode
<ul>
<li>async and sync bit-bang: mask of which data pins are outputs (0 is input, 1 is output)</li>
<li>CBUS bit-bang:
<ul>
<li>bits 0-3: output data</li>
<li>bits 4-7: output pin mask (0 is input, 1 is output)</li>
</ul>
</li>
<li>others: unused?</li>
</ul>
</li>
<li>bits 8-15: mode
<ul>
<li>0x00: reset to base mode</li>
<li>0x01: <a href="bitbang.html">async bit-bang</a></li>
<li>0x02: <a href="mpsse.html">MPSSE</a></li>
<li>0x04: <a href="bitbang.html">sync bit-bang</a></li>
<li>0x08: <a href="mcu-bus.html">MCU host bus</a></li>
<li>0x10: reset <a href="opto.html">fast opto-isolated serial</a> (?!?!?)</li>
<li>0x20: <a href="bitbang.html">CBUS bit-bang</a></li>
<li>0x40: <a href="fifo.html">synchronous 245-style FIFO</a></li>
<li>0x80: allegedly <a href="ft1248.html">FT1248</a> according to libftdi (?!?!?)</li>
</ul>
</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>TODO: figure out the details of this cursed thing</p>
<p>TODO: why are FT1248 and fast opto-isolated serial set both here and in the EEPROM</p>
<p>TODO: CBUS bit-bang has special semantics and can be combined with base mode?!? figure that out</p>
<h3 id="get_pin_state"><a class="header" href="#get_pin_state"><code>GET_PIN_STATE</code></a></h3>
<p>Reads current raw state of the channel's DBUS pins.</p>
<p>FTDI calls this request <code>GET_BITMODE</code>. However, this naming decision is a crime against catgirlkind, and we shall not respect it.</p>
<ul>
<li>applicable to: FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x0c</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: 1</li>
<li>data: pin state</li>
</ul>
<p>TODO: allegedly this reads CBUS state instead of DBUS state when in CBUS bit-bang mode</p>
<h3 id="vendor_cmd_get"><a class="header" href="#vendor_cmd_get"><code>VENDOR_CMD_GET</code></a></h3>
<p>Does a vendor-specific operation with get semantics.  Corresponds to <code>FT_VendorCmdGet</code> and <code>FT_VendorCmdGetEx</code>.</p>
<p>You may be asking yourself why FTDI saw fit to create a space for vendor-defined requests within its vendor-defined requests space as defined by USB, given that it is the defining vendor in both cases.  The answer is that I have no meowing idea.  However, this seems to be where they stuff a bunch of subcommands specific to their weirder devices.</p>
<ul>
<li>applicable to: FT4222H, allegedly UMFTPD3A</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x20</code></li>
<li><code>wValue</code>: request type</li>
<li><code>wIndex</code>: channel (or not, it's vendor-defined after all)</li>
<li><code>wLength</code>: up to <code>0x80</code></li>
</ul>
<p>The request set appears to be specific to the exact device.  For the FT4222H request list, see [TODO].</p>
<h3 id="vendor_cmd_set"><a class="header" href="#vendor_cmd_set"><code>VENDOR_CMD_SET</code></a></h3>
<p>Does a vendor-specific operation with set semantics.  Corresponds to <code>FT_VendorCmdSet</code>.</p>
<ul>
<li>applicable to: FT4222H, allegedly UMFTPD3A</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x21</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: request type</li>
<li>bits 8-15: data, if a single byte of data is transferred</li>
</ul>
</li>
<li><code>wIndex</code>: channel (or not, it's vendor-defined after all)</li>
<li><code>wLength</code>: up to <code>0x80</code></li>
</ul>
<p>If exactly 1 byte is sent to the device, it is put in the high byte of <code>wValue</code>, and <code>wLength</code> is set to 0.  If more than 1 byte is sent to the device, they are all put in the data payload, and the high byte of <code>wValue</code> is unused.</p>
<p>The request set appears to be specific to the exact device.  For the FT4222H request list, see [TODO].</p>
<h3 id="read_eeprom"><a class="header" href="#read_eeprom"><code>READ_EEPROM</code></a></h3>
<p>Reads a 16-bit word from the EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x90</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: word address to read; note that the address is counted in 16-bit words, not bytes</li>
<li><code>wLength</code>: 2</li>
<li>data: word from EEPROM (little-endian)</li>
</ul>
<p>The format of the EEPROM depends on the device.  See the documentation for the particular device.</p>
<h3 id="write_eeprom"><a class="header" href="#write_eeprom"><code>WRITE_EEPROM</code></a></h3>
<p>Writes a 16-bit word into the EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x91</code></li>
<li><code>wValue</code>: word to write to the EEPROM</li>
<li><code>wIndex</code>: word address to write; note that the address is counted in 16-bit words, not bytes</li>
</ul>
<p>Note: on FT232R and FT245R this command is only accepted when the latency timer is set to the magic <code>0x77</code> value.</p>
<p>Note that the EEPROM on FT232R and FT245R devices is 32-bit dword oriented, not 16-bit.  This is completely transparent on reads, but is significant for writes: FT2xxR EEPROM must always be written one aligned dword at a time, with the lower-address word written first.</p>
<p>TODO: what about FT-X series?</p>
<h3 id="erase_eeprom"><a class="header" href="#erase_eeprom"><code>ERASE_EEPROM</code></a></h3>
<p>Erases the entire EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT2232[CDL], FT2232H, FT4232H, FT232H</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x92</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: 0</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fifo-modes"><a class="header" href="#fifo-modes">FIFO modes</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitbang-modes"><a class="header" href="#bitbang-modes">Bitbang modes</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mpsse-mode"><a class="header" href="#mpsse-mode">MPSSE mode</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcu-host-bus-mode"><a class="header" href="#mcu-host-bus-mode">MCU host bus mode</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft1248-mode"><a class="header" href="#ft1248-mode">FT1248 mode</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-opto-isolated-serial-mode"><a class="header" href="#fast-opto-isolated-serial-mode">Fast opto-isolated serial mode</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i2c-peripherial-mode"><a class="header" href="#i2c-peripherial-mode">I2C peripherial mode</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft8u232a-and-ft8u245a-1"><a class="header" href="#ft8u232a-and-ft8u245a-1">FT8U232A and FT8U245A</a></h1>
<p>The first generation of fixed-function D2xx devices.  The devices are:</p>
<ul>
<li>FT8U232AM: UART mode, 32-pin MQFP</li>
<li>FT8U245AM: FIFO mode, 32-pin MQFP</li>
</ul>
<p>Both devices look exactly the same from the software perspective, and in fact may or may not be the same silicon.</p>
<p>Features:</p>
<ul>
<li>is a full-speed USB 1.1 peripherial</li>
<li>single channel D2xx device, hardwired to either UART or FIFO mode
<ul>
<li>no alternate bit modes</li>
</ul>
</li>
<li>384-byte IN FIFO, 128-byte OUT FIFO</li>
<li>48MHz internal base clock, generated from 6MHz crystal</li>
<li>5V VCC supply (used for internal circuitry and business-end IO)</li>
<li>separate AGND and AVCC supply for the clock multiplier</li>
<li>internal 3.3V LDO</li>
<li>required external support circuitry:
<ul>
<li>USB D+ pullup</li>
<li>power-on reset circuit</li>
<li>decoupling capacitor for internal LDO</li>
<li>RC timer for oscillator bootstrap</li>
<li>6MHz crystal</li>
<li>optionally, a 93C46 64×16-bit EEPROM</li>
</ul>
</li>
</ul>
<p>The default VID:PID of the device is <code>0403:6001</code>, unless configured otherwise by the EEPROM.  The <code>bcdDevice</code> value is <code>0x0200</code>.</p>
<h2 id="pinout"><a class="header" href="#pinout">Pinout</a></h2>
<div class="table-wrapper"><table><thead><tr><th>MQFP pin</th><th>category</th><th>FT8U232A</th><th>FT8U245A</th></tr></thead><tbody>
<tr><td>1</td><td>EEPROM</td><td>EESK</td><td>EESK</td></tr>
<tr><td>2</td><td>EEPROM</td><td>EEDATA</td><td>EEDATA</td></tr>
<tr><td>3</td><td>power</td><td>VCC</td><td>VCC</td></tr>
<tr><td>4</td><td>control</td><td>RESET#</td><td>RESET#</td></tr>
<tr><td>5</td><td>control</td><td>TEST</td><td>TEST</td></tr>
<tr><td>6</td><td>power</td><td>3V3OUT</td><td>3V3OUT</td></tr>
<tr><td>7</td><td>USB</td><td>USBDP</td><td>USBDP</td></tr>
<tr><td>8</td><td>USB</td><td>USBDM</td><td>USBDM</td></tr>
<tr><td>9</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>10</td><td>IO</td><td>SLEEP#</td><td>EEGNT#</td></tr>
<tr><td>11</td><td>IO</td><td>RXLED#</td><td>EEREQ#</td></tr>
<tr><td>12</td><td>IO</td><td>TXLED#</td><td>RXF#</td></tr>
<tr><td>13</td><td>power</td><td>VCC</td><td>VCC</td></tr>
<tr><td>14</td><td>IO</td><td>PWRCTL</td><td>TXE#</td></tr>
<tr><td>15</td><td>IO</td><td>USBEN</td><td>WR</td></tr>
<tr><td>16</td><td>IO</td><td>TXDEN</td><td>RD#</td></tr>
<tr><td>17</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>18</td><td>IO</td><td>RI#</td><td>D7</td></tr>
<tr><td>19</td><td>IO</td><td>DCD#</td><td>D6</td></tr>
<tr><td>20</td><td>IO</td><td>DSR#</td><td>D5</td></tr>
<tr><td>21</td><td>IO</td><td>DTR#</td><td>D4</td></tr>
<tr><td>22</td><td>IO</td><td>CTS#</td><td>D3</td></tr>
<tr><td>23</td><td>IO</td><td>RTS#</td><td>D2</td></tr>
<tr><td>24</td><td>IO</td><td>RXD</td><td>D1</td></tr>
<tr><td>25</td><td>IO</td><td>TXD</td><td>D0</td></tr>
<tr><td>26</td><td>power</td><td>VCC</td><td>VCC</td></tr>
<tr><td>27</td><td>clock</td><td>XTIN</td><td>XTIN</td></tr>
<tr><td>28</td><td>clock</td><td>XTOUT</td><td>XTOUT</td></tr>
<tr><td>29</td><td>power</td><td>AGND</td><td>AGND</td></tr>
<tr><td>30</td><td>power</td><td>AVCC</td><td>AVCC</td></tr>
<tr><td>31</td><td>clock</td><td>RCCLK</td><td>RCCLK</td></tr>
<tr><td>32</td><td>EEPROM</td><td>EECS</td><td>EECS</td></tr>
</tbody></table>
</div>
<p>UART-mode IO pins have the following functions:</p>
<ul>
<li>TXD, RXD, RTS#, CTS#, DTR#, DSR#, DCD#, RI#: standard UART pins</li>
<li>SLEEP#: device output, goes low when in USB suspend mode</li>
<li>RXLED#, TXLED#: active-low LED outputs</li>
<li>PWRCTL: device input, used to generate USB descriptors when EEPROM not present or not functional
<ul>
<li>0: bus-powered</li>
<li>1: self-powered</li>
</ul>
</li>
<li>TXDEN: device output, high while TXD is actively transmitting data; can be used as transmitter enable for RS485 transceivers</li>
<li>USBEN: device output, high after the host configures the device</li>
</ul>
<p>FIFO-mode IO pins have the following functions:</p>
<ul>
<li>D0-D7, TXE#, RXF#, RD#, WR: standard FIFO-mode pins</li>
<li>EEREQ#: device input, requests access to EEPROM via data bus</li>
<li>EEGNT#: device output, grants access to EEPROM via data bus</li>
</ul>
<p>The semantics of EEREQ# and EEGNT# are unclear.  They were removed from all subsequent devices.</p>
<p>TODO: wtf is this exactly</p>
<p>The EEPROM interface is 3-pin at the FTDI chip, while the EEPROM itself has a 4-pin interface.  This is because the FTDI device uses a single tied data line.  To connect the EEPROM, connect the FTDI EEDATA pin directly to the ROM's data input, and to the data output via a 2.2kΩ resistor.</p>
<h2 id="eeprom-data-format"><a class="header" href="#eeprom-data-format">EEPROM data format</a></h2>
<ul>
<li>word 0x00: always 0</li>
<li>word 0x01: idVendor (USB VID)</li>
<li>word 0x02: idProduct (USB PID)</li>
<li>word 0x03: bcdDevice (should be 0x200)</li>
<li>word 0x04: USB config (goes straight to configuration descriptor)
<ul>
<li>bits 0-7: bmAttributes
<ul>
<li>bit 5: remote wakeup enabled</li>
<li>bit 6: self-powered</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>bits 8-15: bMaxPower (max power in units of 2mA)</li>
</ul>
</li>
<li>words 0x05, 0x06: always 0</li>
<li>word 0x07: manufacturer string pointer</li>
<li>word 0x08: product description string pointer</li>
<li>word 0x09: serial number string pointer</li>
<li>words 0x0a..0x3f: string / user area</li>
<li>word 0x3f: checksum</li>
</ul>
<p>String pointers are formatted as follows:</p>
<ul>
<li>bits 0-6: pointer to descriptor within EEPROM (counted <em>in bytes</em>)</li>
<li>bit 7: always set to 1</li>
<li>bits 8-15: total length of descriptor in bytes</li>
</ul>
<p>The string descriptors are stored in ROM with the descriptor header included, as follows:</p>
<ul>
<li>word 0: header
<ul>
<li>bits 0-7: total length of descriptor in bytes (includes header)</li>
<li>bits 8-15: descriptor type (always 3 — string)</li>
</ul>
</li>
<li>words 1 and up: string in UTF-16</li>
</ul>
<p>The checksum can be computed as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checksum(eeprom: [u16; 0x40]) -&gt; u16 {
    let mut res: u16 = 0xaaaa;
    for pos in 0..0x3f { // checksum word is NOT included — we're calculating it
        res ^= eeprom[pos];
        res = res.rotate_left(1);
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft232b-and-ft245b-1"><a class="header" href="#ft232b-and-ft245b-1">FT232B and FT245B</a></h1>
<p>The second generation of fixed-function D2xx devices, an upgrade to FT8U232A and FT8U245A.  The devices are:</p>
<ul>
<li>FT232BM: UART mode, 32-pin LQFP</li>
<li>FT232BL: UART mode, 32-pin LQFP (lead-free version)</li>
<li>FT232BQ: UART mode, 32-pin QFN</li>
<li>FT245BM: FIFO mode, 32-pin LQFP</li>
<li>FT245BL: FIFO mode, 32-pin LQFP (lead-free version)</li>
</ul>
<p>Both FT232B and FT245B look exactly the same from the software perspective, and in fact may or may not be the same silicon.</p>
<p>Features:</p>
<ul>
<li>is a full-speed USB 1.1 peripherial</li>
<li>single channel D2xx device, hardwired to either UART or <a href="fifo.html">FIFO</a> base mode
<ul>
<li>can be set to an alternate mode: <a href="bitbang.html">async bitbang</a></li>
</ul>
</li>
<li>384-byte IN FIFO, 128-byte OUT FIFO</li>
<li>48MHz internal base clock, generated from 6MHz crystal</li>
<li>5V VCC supply for internal circuitry</li>
<li>separate 3.3V or 5V VCCIO supply for business-end IO</li>
<li>separate AGND and AVCC 5V supply for the clock multiplier</li>
<li>internal 3.3V LDO</li>
<li>internal power-on reset circuit</li>
<li>required external support circuitry:
<ul>
<li>USB D+ pullup</li>
<li>decoupling capacitor for internal LDO</li>
<li>6MHz crystal or external clock</li>
<li>optionally, a 93C46 64×16-bit EEPROM; a 93C56 or 93C66 is also acceptable, but the device will not be able to access the extra space</li>
</ul>
</li>
</ul>
<p>On reset, the device samples the value of the EESK pin to determine the default VID:PID that will be used unless configured otherwise by the EEPROM.  The default VID:PID is:</p>
<ul>
<li><code>0403:6001</code> if EESK is high (or left floating, as the device has weak internal pullup)</li>
<li><code>0403:6004</code> if EESK is low and the device is an FT232B</li>
<li><code>0403:6005</code> if EESK is low and the device is an FT245B</li>
</ul>
<p>The <code>bcdDevice</code> value for the device is <code>0x0200</code> (same as FT8U2xxA) if no serial number has been configured, or <code>0x0400</code> if a serial number has been configured.</p>
<h2 id="pinout-1"><a class="header" href="#pinout-1">Pinout</a></h2>
<p>The pinout is mostly, but not quite, compatible with FT8U2xxA.</p>
<div class="table-wrapper"><table><thead><tr><th>LQFP / QFN pin</th><th>category</th><th>FT8U232A</th><th>FT8U245A</th></tr></thead><tbody>
<tr><td>1</td><td>EEPROM</td><td>EESK</td><td>EESK</td></tr>
<tr><td>2</td><td>EEPROM</td><td>EEDATA</td><td>EEDATA</td></tr>
<tr><td>3</td><td>power</td><td>VCC</td><td>VCC</td></tr>
<tr><td>4</td><td>control</td><td>RESET#</td><td>RESET#</td></tr>
<tr><td>5</td><td>control</td><td>RSTOUT#</td><td>RSTOUT#</td></tr>
<tr><td>6</td><td>power</td><td>3V3OUT</td><td>3V3OUT</td></tr>
<tr><td>7</td><td>USB</td><td>USBDP</td><td>USBDP</td></tr>
<tr><td>8</td><td>USB</td><td>USBDM</td><td>USBDM</td></tr>
<tr><td>9</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>10</td><td>IO</td><td>SLEEP#</td><td>PWREN#</td></tr>
<tr><td>11</td><td>IO</td><td>RXLED#</td><td>SI/WU#</td></tr>
<tr><td>12</td><td>IO</td><td>TXLED#</td><td>RXF#</td></tr>
<tr><td>13</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>14</td><td>IO</td><td>PWRCTL</td><td>TXE#</td></tr>
<tr><td>15</td><td>IO</td><td>PWREN#</td><td>WR</td></tr>
<tr><td>16</td><td>IO</td><td>TXDEN</td><td>RD#</td></tr>
<tr><td>17</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>18</td><td>IO</td><td>RI#</td><td>D7</td></tr>
<tr><td>19</td><td>IO</td><td>DCD#</td><td>D6</td></tr>
<tr><td>20</td><td>IO</td><td>DSR#</td><td>D5</td></tr>
<tr><td>21</td><td>IO</td><td>DTR#</td><td>D4</td></tr>
<tr><td>22</td><td>IO</td><td>CTS#</td><td>D3</td></tr>
<tr><td>23</td><td>IO</td><td>RTS#</td><td>D2</td></tr>
<tr><td>24</td><td>IO</td><td>RXD</td><td>D1</td></tr>
<tr><td>25</td><td>IO</td><td>TXD</td><td>D0</td></tr>
<tr><td>26</td><td>power</td><td>VCC</td><td>VCC</td></tr>
<tr><td>27</td><td>clock</td><td>XTIN</td><td>XTIN</td></tr>
<tr><td>28</td><td>clock</td><td>XTOUT</td><td>XTOUT</td></tr>
<tr><td>29</td><td>power</td><td>AGND</td><td>AGND</td></tr>
<tr><td>30</td><td>power</td><td>AVCC</td><td>AVCC</td></tr>
<tr><td>31</td><td>control</td><td>TEST</td><td>TEST</td></tr>
<tr><td>32</td><td>EEPROM</td><td>EECS</td><td>EECS</td></tr>
</tbody></table>
</div>
<p>UART-mode IO pins have the following functions:</p>
<ul>
<li>TXD, RXD, RTS#, CTS#, DTR#, DSR#, DCD#, RI#: standard UART pins</li>
<li>SLEEP#: device output, goes low when in USB suspend mode</li>
<li>RXLED#, TXLED#: active-low LED outputs</li>
<li>PWRCTL: device input, used to generate USB descriptors when EEPROM not present or not functional
<ul>
<li>0: bus-powered</li>
<li>1: self-powered</li>
</ul>
</li>
<li>TXDEN: device output, high while TXD is actively transmitting data; can be used as transmitter enable for RS485 transceivers</li>
<li>PWREN#: device output, low when the device has been configured by the host and is not in suspend mode (can be used to gate power to the rest of the board)</li>
</ul>
<p>FIFO-mode IO pins have the following functions:</p>
<ul>
<li>D0-D7, TXE#, RXF#, RD#, WR, SI/WU#: standard FIFO-mode pins</li>
<li>PWREN#: like in UART mode</li>
</ul>
<p>The EEPROM interface is 3-pin at the FTDI chip, while the EEPROM itself has a 4-pin interface.  This is because the FTDI device uses a single tied data line.  To connect the EEPROM, connect the FTDI EEDATA pin directly to the ROM's data input, and to the data output via a 2.2kΩ resistor.</p>
<h2 id="eeprom-data-format-1"><a class="header" href="#eeprom-data-format-1">EEPROM data format</a></h2>
<p>The format is backwards-compatible with the one used by FT8U2xxA devices.</p>
<ul>
<li>word 0x00: always 0</li>
<li>word 0x01: idVendor (USB VID)</li>
<li>word 0x02: idProduct (USB PID)</li>
<li>word 0x03: bcdDevice (should be 0x400 or 0x200 when serial number not present)</li>
<li>word 0x04: USB config (goes straight to configuration descriptor)
<ul>
<li>bits 0-7: bmAttributes
<ul>
<li>bit 5: remote wakeup enabled</li>
<li>bit 6: self-powered</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>bits 8-15: bMaxPower (max power in units of 2mA)</li>
</ul>
</li>
<li>word 0x05: device control
<ul>
<li>bit 0: IN endpoint is isochronous</li>
<li>bit 1: OUT endpoint is isochronous</li>
<li>bit 2: IO pulldown in suspend</li>
<li>bit 3: serial number enabled</li>
<li>bit 4: bcdUSB is present</li>
</ul>
</li>
<li>word 0x06: bcdUSB</li>
<li>word 0x07: manufacturer string pointer</li>
<li>word 0x08: product description string pointer</li>
<li>word 0x09: serial number string pointer</li>
<li>words 0x0a..0x3f: string / user area</li>
<li>word 0x3f: checksum</li>
</ul>
<p>String pointers are formatted as follows:</p>
<ul>
<li>bits 0-6: pointer to descriptor within EEPROM (counted <em>in bytes</em>)</li>
<li>bit 7: always set to 1</li>
<li>bits 8-15: total length of descriptor in bytes</li>
</ul>
<p>The string descriptors are stored in ROM with the descriptor header included, as follows:</p>
<ul>
<li>word 0: header
<ul>
<li>bits 0-7: total length of descriptor in bytes (includes header)</li>
<li>bits 8-15: descriptor type (always 3 — string)</li>
</ul>
</li>
<li>words 1 and up: string in UTF-16</li>
</ul>
<p>The checksum can be computed as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checksum(eeprom: [u16; 0x40]) -&gt; u16 {
    let mut res: u16 = 0xaaaa;
    for pos in 0..0x3f { // checksum word is NOT included — we're calculating it
        res ^= eeprom[pos];
        res = res.rotate_left(1);
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft2232cdl-1"><a class="header" href="#ft2232cdl-1">FT2232[CDL]</a></h1>
<p>The third generation of fixed-function D2xx devices, now with two channels.  The devices are:</p>
<ul>
<li>FT2232C: first revision; 48-pin LQFP package</li>
<li>FT2232L: first revision; 48-pin LQFP package (lead-free version)</li>
<li>FT2232D: second revision, fixed CPU FIFO mode; 48-pin LQFP package (lead-free version)</li>
</ul>
<p>The FT2232H is an entirely different device, and is not described here.</p>
<p>Features:</p>
<ul>
<li>is a full-speed USB 1.1 peripherial</li>
<li>dual-channel D2xx device</li>
<li>each channel can be independently configured to one of several supported modes:
<ul>
<li>FT232B-like UART mode (default)</li>
<li>FT245B-like <a href="fifo.html">FIFO mode</a> (selected in EEPROM)</li>
<li>new <a href="fifo.html">CPU FIFO mode</a> (selected in EEPROM; FT2232D only — this mode is present but unusably broken on FT2232C)</li>
<li>FT2xxB-like <a href="bitbang.html">async bitbang mode</a> (dynamically selected)</li>
<li>new <a href="bitbang.html">sync bitbang mode</a> (dynamically selected)</li>
<li>new <a href="mpsse.html">MPSSE mode</a> (dynamically selected; channel A only)</li>
<li>new <a href="opto.html">fast opto-isolated serial mode</a> (selected in EEPROM)</li>
<li>new <a href="mcu-bus.html">MCU bus controller mode</a> (dynamically selected; uses both channels)</li>
</ul>
</li>
<li>384-byte IN FIFOs, 128-byte OUT FIFOs (per channel)</li>
<li>48MHz internal base clock, generated from 6MHz crystal</li>
<li>5V VCC supply for internal circuitry</li>
<li>separate 3.3V or 5V VCCIOA supply for channel A business-end IO</li>
<li>separate 3.3V or 5V VCCIOB supply for channel B business-end IO</li>
<li>separate AGND and AVCC 5V supply for the clock multiplier</li>
<li>internal 3.3V LDO</li>
<li>internal power-on reset circuit</li>
<li>required external support circuitry:
<ul>
<li>USB D+ pullup</li>
<li>decoupling capacitor for internal LDO</li>
<li>6MHz crystal or external clock</li>
<li>optionally, a 93C46 (64×16-bit), 93C56 (128×16-bit), or 93C66 (256×16-bit) EEPROM</li>
</ul>
</li>
</ul>
<p>The default VID:PID of the device is <code>0403:6010</code>, unless configured otherwise by the EEPROM.  The <code>bcdDevice</code> value is <code>0x0500</code>.</p>
<h2 id="pinout-2"><a class="header" href="#pinout-2">Pinout</a></h2>
<div class="table-wrapper"><table><thead><tr><th>pin</th><th>category</th><th>function</th></tr></thead><tbody>
<tr><td>1</td><td>EEPROM</td><td>EESK</td></tr>
<tr><td>2</td><td>EEPROM</td><td>EEDATA</td></tr>
<tr><td>3</td><td>power</td><td>VCC</td></tr>
<tr><td>4</td><td>control</td><td>RESET#</td></tr>
<tr><td>5</td><td>control</td><td>RSTOUT#</td></tr>
<tr><td>6</td><td>power</td><td>3V3OUT</td></tr>
<tr><td>7</td><td>USB</td><td>USBDP</td></tr>
<tr><td>8</td><td>USB</td><td>USBDM</td></tr>
<tr><td>9</td><td>power</td><td>GND</td></tr>
<tr><td>10</td><td>IO-A</td><td>SI/WUA</td></tr>
<tr><td>11</td><td>IO-A</td><td>ACBUS3</td></tr>
<tr><td>12</td><td>IO-A</td><td>ACBUS2</td></tr>
<tr><td>13</td><td>IO-A</td><td>ACBUS1</td></tr>
<tr><td>14</td><td>power</td><td>VCCIOA</td></tr>
<tr><td>15</td><td>IO-A</td><td>ACBUS0</td></tr>
<tr><td>16</td><td>IO-A</td><td>ADBUS7</td></tr>
<tr><td>17</td><td>IO-A</td><td>ADBUS6</td></tr>
<tr><td>18</td><td>power</td><td>GND</td></tr>
<tr><td>19</td><td>IO-A</td><td>ADBUS5</td></tr>
<tr><td>20</td><td>IO-A</td><td>ADBUS4</td></tr>
<tr><td>21</td><td>IO-A</td><td>ADBUS3</td></tr>
<tr><td>22</td><td>IO-A</td><td>ADBUS2</td></tr>
<tr><td>23</td><td>IO-A</td><td>ADBUS1</td></tr>
<tr><td>24</td><td>IO-A</td><td>ADBUS0</td></tr>
<tr><td>25</td><td>power</td><td>GND</td></tr>
<tr><td>26</td><td>IO-B</td><td>SI/WUB</td></tr>
<tr><td>27</td><td>IO-B</td><td>BCBUS3</td></tr>
<tr><td>28</td><td>IO-B</td><td>BCBUS2</td></tr>
<tr><td>29</td><td>IO-B</td><td>BCBUS1</td></tr>
<tr><td>30</td><td>IO-B</td><td>BCBUS0</td></tr>
<tr><td>31</td><td>power</td><td>VCCIOB</td></tr>
<tr><td>32</td><td>IO-B</td><td>BDBUS7</td></tr>
<tr><td>33</td><td>IO-B</td><td>BDBUS6</td></tr>
<tr><td>34</td><td>power</td><td>GND</td></tr>
<tr><td>35</td><td>IO-B</td><td>BDBUS5</td></tr>
<tr><td>36</td><td>IO-B</td><td>BDBUS4</td></tr>
<tr><td>37</td><td>IO-B</td><td>BDBUS3</td></tr>
<tr><td>38</td><td>IO-B</td><td>BDBUS2</td></tr>
<tr><td>39</td><td>IO-B</td><td>BDBUS1</td></tr>
<tr><td>40</td><td>IO-B</td><td>BDBUS0</td></tr>
<tr><td>41</td><td>control</td><td>PWREN#</td></tr>
<tr><td>42</td><td>power</td><td>VCC</td></tr>
<tr><td>43</td><td>clock</td><td>XTIN</td></tr>
<tr><td>44</td><td>clock</td><td>XTOUT</td></tr>
<tr><td>45</td><td>power</td><td>AGND</td></tr>
<tr><td>46</td><td>power</td><td>AVCC</td></tr>
<tr><td>47</td><td>control</td><td>TEST</td></tr>
<tr><td>48</td><td>EEPROM</td><td>EECS</td></tr>
</tbody></table>
</div>
<h2 id="pin-functions-per-mode"><a class="header" href="#pin-functions-per-mode">Pin functions per mode</a></h2>
<div class="table-wrapper"><table><thead><tr><th>pin</th><th>UART</th><th>FIFO</th><th>CPU FIFO</th><th>bitbang (U)</th><th>bitbang (F)</th><th>MPSSE</th><th>MCU bus</th><th>opto-isolated</th></tr></thead><tbody>
<tr><td>ADBUS0</td><td>TXD</td><td>D0</td><td>D0</td><td>D0</td><td>D0</td><td>TCK/SK</td><td>AD0</td><td>-</td></tr>
<tr><td>ADBUS1</td><td>RXD</td><td>D1</td><td>D1</td><td>D1</td><td>D1</td><td>TDI/DO</td><td>AD1</td><td>-</td></tr>
<tr><td>ADBUS2</td><td>RTS#</td><td>D2</td><td>D2</td><td>D2</td><td>D2</td><td>TDO/DI</td><td>AD2</td><td>-</td></tr>
<tr><td>ADBUS3</td><td>CTS#</td><td>D3</td><td>D3</td><td>D3</td><td>D3</td><td>TMS/CS</td><td>AD3</td><td>-</td></tr>
<tr><td>ADBUS4</td><td>DTR#</td><td>D4</td><td>D4</td><td>D4</td><td>D4</td><td>GPIOL0</td><td>AD4</td><td>-</td></tr>
<tr><td>ADBUS5</td><td>DSR#</td><td>D5</td><td>D5</td><td>D5</td><td>D5</td><td>GPIOL1</td><td>AD5</td><td>-</td></tr>
<tr><td>ADBUS6</td><td>DCD#</td><td>D6</td><td>D6</td><td>D6</td><td>D6</td><td>GPIOL2</td><td>AD6</td><td>-</td></tr>
<tr><td>ADBUS7</td><td>RI#</td><td>D7</td><td>D7</td><td>D7</td><td>D7</td><td>GPIOL3</td><td>AD7</td><td>-</td></tr>
<tr><td>ACBUS0</td><td>TXDEN</td><td>RXF#</td><td>CS#</td><td>-</td><td>WR#</td><td>GPIOH0</td><td>I/O0</td><td>-</td></tr>
<tr><td>ACBUS1</td><td>SLEEP#</td><td>TXE#</td><td>A0</td><td>-</td><td>RD#</td><td>GPIOH1</td><td>I/O1</td><td>-</td></tr>
<tr><td>ACBUS2</td><td>RXLED#</td><td>RD#</td><td>RD#</td><td>WR#</td><td>-</td><td>GPIOH2</td><td>IORDY</td><td>-</td></tr>
<tr><td>ACBUS3</td><td>TXLED#</td><td>WR</td><td>WR#</td><td>RD#</td><td>-</td><td>GPIOH3</td><td>OSC</td><td>-</td></tr>
<tr><td>SI/WUA</td><td>SI/WU</td><td>SI/WU</td><td>- (?)</td><td>SI/WU</td><td>SI/WU</td><td>N/A</td><td>-</td><td>-</td></tr>
<tr><td>BDBUS0</td><td>TXD</td><td>D0</td><td>D0</td><td>D0</td><td>D0</td><td>N/A</td><td>A8</td><td>FSDI</td></tr>
<tr><td>BDBUS1</td><td>RXD</td><td>D1</td><td>D1</td><td>D1</td><td>D1</td><td>N/A</td><td>A9</td><td>FSCLK</td></tr>
<tr><td>BDBUS2</td><td>RTS#</td><td>D2</td><td>D2</td><td>D2</td><td>D2</td><td>N/A</td><td>A10</td><td>FSDO</td></tr>
<tr><td>BDBUS3</td><td>CTS#</td><td>D3</td><td>D3</td><td>D3</td><td>D3</td><td>N/A</td><td>A11</td><td>FSCTS</td></tr>
<tr><td>BDBUS4</td><td>DTR#</td><td>D4</td><td>D4</td><td>D4</td><td>D4</td><td>N/A</td><td>A12</td><td>-</td></tr>
<tr><td>BDBUS5</td><td>DSR#</td><td>D5</td><td>D5</td><td>D5</td><td>D5</td><td>N/A</td><td>A13</td><td>-</td></tr>
<tr><td>BDBUS6</td><td>DCD#</td><td>D6</td><td>D6</td><td>D6</td><td>D6</td><td>N/A</td><td>A14</td><td>-</td></tr>
<tr><td>BDBUS7</td><td>RI#</td><td>D7</td><td>D7</td><td>D7</td><td>D7</td><td>N/A</td><td>A15</td><td>-</td></tr>
<tr><td>BCBUS0</td><td>TXDEN</td><td>RXF#</td><td>CS#</td><td>-</td><td>WR#</td><td>N/A</td><td>CS#</td><td>-</td></tr>
<tr><td>BCBUS1</td><td>SLEEP#</td><td>TXE#</td><td>A0</td><td>-</td><td>RD#</td><td>N/A</td><td>ALE</td><td>-</td></tr>
<tr><td>BCBUS2</td><td>RXLED#</td><td>RD#</td><td>RD#</td><td>WR#</td><td>-</td><td>N/A</td><td>RD#</td><td>-</td></tr>
<tr><td>BCBUS3</td><td>TXLED#</td><td>WR</td><td>WR#</td><td>RD#</td><td>-</td><td>N/A</td><td>WR#</td><td>-</td></tr>
<tr><td>SI/WUB</td><td>SI/WU</td><td>SI/WU</td><td>- (?)</td><td>SI/WU</td><td>SI/WU</td><td>N/A</td><td>-</td><td>SI/WU</td></tr>
</tbody></table>
</div>
<p>Note: for bitbang modes, the pin assignments in the "bitbang (U)" column apply when the base mode of the channel is UART, and the "bitbang (F)" column applies otherwise.</p>
<h2 id="eeprom-data-format-2"><a class="header" href="#eeprom-data-format-2">EEPROM data format</a></h2>
<p>The device will accept 64-word, 128-word, and 256-word EEPROMs.  In case of 256-word EEPROMs, only first half is covered by the checksum.  The other half can still be used to store user data.</p>
<ul>
<li>word 0x00:
<ul>
<li>bits 0-2: channel A mode
<ul>
<li>0: UART</li>
<li>1: <a href="fifo.html">245-style FIFO</a></li>
<li>2: <a href="fifo.html">CPU FIFO</a></li>
<li>4: <a href="opto.html">fast opto-isolated serial</a></li>
</ul>
</li>
<li>bit 3: channel A enable bind to VCP driver</li>
<li>bit 4: channel A high current output drive</li>
<li>bits 8-10: channel B mode (see above)</li>
<li>bit 11: channel B enable bind to VCP driver</li>
<li>bit 12: channel B high current output drive</li>
</ul>
</li>
<li>word 0x01: idVendor (USB VID)</li>
<li>word 0x02: idProduct (USB PID)</li>
<li>word 0x03: bcdDevice (0x500)</li>
<li>word 0x04: USB config (goes straight to configuration descriptor)
<ul>
<li>bits 0-7: bmAttributes
<ul>
<li>bit 5: remote wakeup enabled</li>
<li>bit 6: self-powered</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>bits 8-15: bMaxPower (max power in units of 2mA)</li>
</ul>
</li>
<li>word 0x05: device control
<ul>
<li>bit 0: channel A IN endpoint is isochronous</li>
<li>bit 1: channel A OUT endpoint is isochronous</li>
<li>bit 2: IO pulldown in suspend</li>
<li>bit 3: serial number enabled</li>
<li>bit 4: bcdUSB is present</li>
<li>bit 5: channel B IN endpoint is isochronous</li>
<li>bit 6: channel B OUT endpoint is isochronous</li>
</ul>
</li>
<li>word 0x06: bcdUSB</li>
<li>word 0x07: manufacturer string pointer</li>
<li>word 0x08: product description string pointer</li>
<li>word 0x09: serial number string pointer</li>
<li>word 0x0a: EEPROM type
<ul>
<li>0x46: 93C46 (64-word)</li>
<li>0x56: 93C56 (128-word)</li>
<li>0x66: 93C66 (256-word)</li>
</ul>
</li>
<li>for 64-word EEPROM:
<ul>
<li>words 0x0b..0x3f: string / user area</li>
<li>word 0x3f: checksum</li>
</ul>
</li>
<li>for 128-word and 256-word EEPROM:
<ul>
<li>words 0xb..0x4b: user area</li>
<li>words 0x4b..0x7f: string / user area</li>
<li>word 0x7f: checksum</li>
</ul>
</li>
<li>words 0x80..0x100 (256-word EEPROM only): user area (not covered by checksum)</li>
</ul>
<p>String pointers are formatted as follows:</p>
<ul>
<li>for 64-word EEPROM:
<ul>
<li>bits 0-6: pointer to descriptor within EEPROM (counted <em>in bytes</em>)</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>for 128-word or 256-word EEPROM: pointer to descriptor within EEPROM (counted <em>in bytes</em>); note that FTDI tools will only store string descriptors in the area starting at word 0x4b, ensuring the high bit is always set</li>
<li>bits 8-15: total length of descriptor in bytes</li>
</ul>
<p>TODO: figure out wtf it is with the always-set high bit</p>
<p>The string descriptors are stored in ROM with the descriptor header included, as follows:</p>
<ul>
<li>word 0: header
<ul>
<li>bits 0-7: total length of descriptor in bytes (includes header)</li>
<li>bits 8-15: descriptor type (always 3 — string)</li>
</ul>
</li>
<li>words 1 and up: string in UTF-16</li>
</ul>
<p>The checksum can be computed as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checksum(eeprom: &amp;[u16]) -&gt; u16 {
    let checksum_word = match eeprom.len() {
        0x40 =&gt; 0x3f,
        0x80 | 0x100 =&gt; 0x7f,
    };
    let mut res: u16 = 0xaaaa;
    for pos in 0..checksum_word { // checksum word is NOT included — we're calculating it
        res ^= eeprom[pos];
        res = res.rotate_left(1);
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft232r-and-ft245r"><a class="header" href="#ft232r-and-ft245r">FT232R and FT245R</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft2232h-and-ft4232h-1"><a class="header" href="#ft2232h-and-ft4232h-1">FT2232H and FT4232H</a></h1>
<p>The fifth generation of fixed-function D2xx devices.  There are two base devices:</p>
<ul>
<li>FT2232H: has two channels with 16 IO pins each and a large selection of operating modes</li>
<li>FT4232H: has four channels with 8 IO pins each and a smaller selection of operating modes</li>
</ul>
<p>Both of these devices are actually the same silicon, and are thus highly similar.  Whether a device is FT2232H or FT4232H is determined by a fuse programmed at the factory.  Note that the <a href="ft232h.html">FT232H</a> is not another variant of the same silicon, but a completely distinct device with different capabilities.</p>
<p>The devices have automotive variants, known as FT2232HA and FT4232HA.  It is not known what their functional differences are, if any.</p>
<p>The devices also have USB-PD variants, which integrate a power delivery core into the same die.  The D2xx function and the power delivery function are largely separate and operate independently, but they do share the same configuration EEPROM.  The USB-PD variants are:</p>
<ul>
<li>FT2233HP and FT4233HP: two USB-PD ports</li>
<li>FT2232HP and FT4232HP: one USB-PD port (actually identical to FTx233HP with the extra port unbonded)</li>
</ul>
<p>All USB-PD variants are the same silicon (which is distinct from the "base" FT2232H silicon).</p>
<p>This document will use the name FT2232H to refer to FT2232HA/FT2232HP/FT2233HP as well, unless otherwise specified.  The same applies for FT4232H.</p>
<p>Features:</p>
<ul>
<li>is a high-speed USB 2.0 peripherial
<ul>
<li>supports higher UART baud rates and bitbang/FIFO/MPSSE speeds thanks to the extra oomph</li>
<li>integrated D+ pullup registor</li>
</ul>
</li>
<li>dual-channel (FT2232H) or quad-channel (FT4232H)</li>
<li>each channel can be independently configured to one of several supported modes:
<ul>
<li>FT232B-like UART mode (default)</li>
<li>FT245B-like <a href="fifo.html">FIFO mode</a> (selected in EEPROM; FT2232H only)</li>
<li>new <a href="fifo.html">synchronous FIFO mode</a> (dynamically selected variant of FIFO mode; FT2232H only)
<ul>
<li>available on channel A only</li>
<li>NOTE: channel B cannot be used while this mode is active, as it reuses channel B's buffer resources</li>
</ul>
</li>
<li>FT2232D-like <a href="fifo.html">CPU FIFO mode</a> (selected in EEPROM; FT2232H only)</li>
<li>FT2xxB-like <a href="bitbang.html">async bitbang mode</a> (dynamically selected)</li>
<li>FT2232C-like <a href="bitbang.html">sync bitbang mode</a> (dynamically selected)</li>
<li>FT2232C-like <a href="mpsse.html">MPSSE mode</a> (dynamically selected)
<ul>
<li>on FT2232H, supported on both channels (an improvement from FT2232C)</li>
<li>on FT4232H, supported on channels A and B only</li>
</ul>
</li>
<li>FT2232C-like <a href="opto.html">fast opto-isolated serial mode</a> (selected in EEPROM; FT2232H only)</li>
<li>FT2232C-like <a href="mcu-bus.html">MCU bus controller mode</a> (dynamically selected; FT2232H only, uses both channels)</li>
</ul>
</li>
<li>FT2232H: 4kiB IN FIFO and 4kiB OUT FIFO for each channel</li>
<li>FT4232H: 2kiB IN FIFO and 2kiB OUT FIFO for each channel</li>
<li>120MHz internal base clock, generated from 12MHz crystal</li>
<li>internal 3.3V to 1.8V LDO</li>
<li>1.8V VCORE power supply for internal logic; can be connected to internal LDO</li>
<li>3.3V VCCIO power supply for business-end IO</li>
<li>3.3V VPHY power supply for USB PHY</li>
<li>3.3V separate AGND and VPLL power supply for PHY PLL</li>
<li>internal power-on reset circuit</li>
<li>required external support circuitry:
<ul>
<li>precision resistor for PHY current reference</li>
<li>VBUS to 3.3V LDO (or other 3.3V power source)</li>
<li>decoupling capacitor for internal LDO</li>
<li>12MHz crystal</li>
<li>optionally, a 93LC46 (64×16-bit), 93LC56 (128×16-bit), or 93LC66 (256×16-bit) EEPROM</li>
</ul>
</li>
</ul>
<p>The full list of devices is:</p>
<div class="table-wrapper"><table><thead><tr><th>device</th><th>channels</th><th>USB-PD ports</th><th>default VID:PID</th><th><code>bcdDevice</code></th><th>package</th></tr></thead><tbody>
<tr><td>FT2232HL</td><td>2</td><td>-</td><td><code>0403:6010</code></td><td><code>0x0700</code></td><td>64-pin LQFP</td></tr>
<tr><td>FT2232HQ</td><td>2</td><td>-</td><td><code>0403:6010</code></td><td><code>0x0700</code></td><td>64-pin QFN</td></tr>
<tr><td>FT2232H-56Q</td><td>2</td><td>-</td><td><code>0403:6010</code></td><td><code>0x0700</code></td><td>56-pin VQFN</td></tr>
<tr><td>FT4232HL</td><td>4</td><td>-</td><td><code>0403:6011</code></td><td><code>0x0800</code></td><td>64-pin LQFP</td></tr>
<tr><td>FT4232HQ</td><td>4</td><td>-</td><td><code>0403:6011</code></td><td><code>0x0800</code></td><td>64-pin QFN</td></tr>
<tr><td>FT4232H-56Q</td><td>4</td><td>-</td><td><code>0403:6011</code></td><td><code>0x0800</code></td><td>56-pin VQFN</td></tr>
<tr><td>FT2233HPQ</td><td>2</td><td>2</td><td><code>0403:6040</code></td><td><code>0x2800</code></td><td>76-pin QFN</td></tr>
<tr><td>FT4233HPQ</td><td>4</td><td>2</td><td><code>0403:6041</code></td><td><code>0x2900</code></td><td>76-pin QFN</td></tr>
<tr><td>FT2232HPQ</td><td>2</td><td>1</td><td><code>0403:6042</code></td><td><code>0x2a00</code></td><td>68-pin QFN</td></tr>
<tr><td>FT4232HPQ</td><td>4</td><td>1</td><td><code>0403:6043</code></td><td><code>0x2b00</code></td><td>68-pin QFN</td></tr>
<tr><td>FT2232HA?</td><td>2</td><td>-</td><td><code>0403:6047</code></td><td><code>0x3500</code></td><td>???</td></tr>
<tr><td>FT4232HAQ</td><td>4</td><td>-</td><td><code>0403:6048</code></td><td><code>0x3600</code></td><td>64-pin QFN</td></tr>
</tbody></table>
</div>
<p>Note: while FT2232HA is supported by the drivers, there is no datasheet available, thus packaging options are unknown.  However, "same as FT4232HA" is probably a good bet.</p>
<p>TODO: USB-PD stuff.</p>
<h2 id="pinout--base-and-automotive-devices"><a class="header" href="#pinout--base-and-automotive-devices">Pinout — base and automotive devices</a></h2>
<div class="table-wrapper"><table><thead><tr><th>LQFP64 or QFN64 pin</th><th>VQFN56 pin</th><th>category</th><th>FT2232H</th><th>FT4232H</th></tr></thead><tbody>
<tr><td>1</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>2</td><td>3</td><td>clock</td><td>OSCI</td><td>OSCI</td></tr>
<tr><td>3</td><td>4</td><td>clock</td><td>OSCO</td><td>OSCO</td></tr>
<tr><td>4</td><td>5</td><td>power</td><td>VPHY</td><td>VPHY</td></tr>
<tr><td>5</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>6</td><td>6</td><td>reference</td><td>REF</td><td>REF</td></tr>
<tr><td>7</td><td>7</td><td>USB</td><td>DM</td><td>DM</td></tr>
<tr><td>8</td><td>8</td><td>USB</td><td>DP</td><td>DP</td></tr>
<tr><td>9</td><td>9</td><td>power</td><td>VPLL</td><td>VPLL</td></tr>
<tr><td>10</td><td>-</td><td>power</td><td>AGND</td><td>AGND</td></tr>
<tr><td>11</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>12</td><td>-</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>13</td><td>10</td><td>control</td><td>TEST</td><td>TEST</td></tr>
<tr><td>14</td><td>11</td><td>control</td><td>RESET#</td><td>RESET#</td></tr>
<tr><td>15</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>16</td><td>12</td><td>IO-A</td><td>ADBUS0</td><td>ADBUS0</td></tr>
<tr><td>17</td><td>13</td><td>IO-A</td><td>ADBUS1</td><td>ADBUS1</td></tr>
<tr><td>18</td><td>14</td><td>IO-A</td><td>ADBUS2</td><td>ADBUS2</td></tr>
<tr><td>19</td><td>15</td><td>IO-A</td><td>ADBUS3</td><td>ADBUS3</td></tr>
<tr><td>20</td><td>16</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>21</td><td>17</td><td>IO-A</td><td>ADBUS4</td><td>ADBUS4</td></tr>
<tr><td>22</td><td>18</td><td>IO-A</td><td>ADBUS5</td><td>ADBUS5</td></tr>
<tr><td>23</td><td>19</td><td>IO-A</td><td>ADBUS6</td><td>ADBUS6</td></tr>
<tr><td>24</td><td>20</td><td>IO-A</td><td>ADBUS7</td><td>ADBUS7</td></tr>
<tr><td>25</td><td>21</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>26</td><td>22</td><td>IO-B</td><td>ACBUS0</td><td>BDBUS0</td></tr>
<tr><td>27</td><td>23</td><td>IO-B</td><td>ACBUS1</td><td>BDBUS1</td></tr>
<tr><td>28</td><td>24</td><td>IO-B</td><td>ACBUS2</td><td>BDBUS2</td></tr>
<tr><td>29</td><td>25</td><td>IO-B</td><td>ACBUS3</td><td>BDBUS3</td></tr>
<tr><td>30</td><td>26</td><td>IO-B</td><td>ACBUS4</td><td>BDBUS4</td></tr>
<tr><td>31</td><td>-</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>32</td><td>27</td><td>IO-B</td><td>ACBUS5</td><td>BDBUS5</td></tr>
<tr><td>33</td><td>28</td><td>IO-B</td><td>ACBUS6</td><td>BDBUS6</td></tr>
<tr><td>34</td><td>29</td><td>IO-B</td><td>ACBUS7</td><td>BDBUS7</td></tr>
<tr><td>35</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>36</td><td>30</td><td>IO-shared</td><td>SUSPEND#</td><td>SUSPEND#</td></tr>
<tr><td>37</td><td>31</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>38</td><td>32</td><td>IO-C</td><td>BDBUS0</td><td>CDBUS0</td></tr>
<tr><td>39</td><td>33</td><td>IO-C</td><td>BDBUS1</td><td>CDBUS1</td></tr>
<tr><td>40</td><td>34</td><td>IO-C</td><td>BDBUS2</td><td>CDBUS2</td></tr>
<tr><td>41</td><td>35</td><td>IO-C</td><td>BDBUS3</td><td>CDBUS3</td></tr>
<tr><td>42</td><td>36</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>43</td><td>37</td><td>IO-C</td><td>BDBUS4</td><td>CDBUS4</td></tr>
<tr><td>44</td><td>38</td><td>IO-C</td><td>BDBUS5</td><td>CDBUS5</td></tr>
<tr><td>45</td><td>39</td><td>IO-C</td><td>BDBUS6</td><td>CDBUS6</td></tr>
<tr><td>46</td><td>40</td><td>IO-C</td><td>BDBUS7</td><td>CDBUS7</td></tr>
<tr><td>47</td><td>41</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>48</td><td>42</td><td>IO-D</td><td>BCBUS0</td><td>DDBUS0</td></tr>
<tr><td>49</td><td>43</td><td>power</td><td>VREGOUT</td><td>VREGOUT</td></tr>
<tr><td>50</td><td>44</td><td>power</td><td>VREGIN</td><td>VREGIN</td></tr>
<tr><td>51</td><td>45</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>52</td><td>46</td><td>IO-D</td><td>BCBUS1</td><td>DDBUS1</td></tr>
<tr><td>53</td><td>47</td><td>IO-D</td><td>BCBUS2</td><td>DDBUS2</td></tr>
<tr><td>54</td><td>48</td><td>IO-D</td><td>BCBUS3</td><td>DDBUS3</td></tr>
<tr><td>55</td><td>49</td><td>IO-D</td><td>BCBUS4</td><td>DDBUS4</td></tr>
<tr><td>56</td><td>50</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>57</td><td>51</td><td>IO-D</td><td>BCBUS5</td><td>DDBUS5</td></tr>
<tr><td>58</td><td>52</td><td>IO-D</td><td>BCBUS6</td><td>DDBUS6</td></tr>
<tr><td>59</td><td>53</td><td>IO-D</td><td>BCBUS7</td><td>DDBUS7</td></tr>
<tr><td>60</td><td>54</td><td>IO-shared</td><td>PWREN#</td><td>PWREN#</td></tr>
<tr><td>61</td><td>55</td><td>EEPROM</td><td>EEDATA</td><td>EEDATA</td></tr>
<tr><td>62</td><td>56</td><td>EEPROM</td><td>EECLK</td><td>EECLK</td></tr>
<tr><td>63</td><td>1</td><td>EEPROM</td><td>EECS</td><td>EECS</td></tr>
<tr><td>64</td><td>2</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
</tbody></table>
</div>
<h2 id="pinout--usb-pd-devices"><a class="header" href="#pinout--usb-pd-devices">Pinout — USB-PD devices</a></h2>
<div class="table-wrapper"><table><thead><tr><th>QFN76</th><th>QFN68</th><th>category</th><th>FT2232H</th><th>FT4232H</th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>EEPROM</td><td>EECLK</td><td>EECLK</td></tr>
<tr><td>2</td><td>2</td><td>EEPROM</td><td>EEDATA</td><td>EEDATA</td></tr>
<tr><td>3</td><td>3</td><td>control</td><td>TEST</td><td>TEST</td></tr>
<tr><td>4</td><td>4</td><td>control</td><td>RESET#</td><td>RESET#</td></tr>
<tr><td>5</td><td>5</td><td>IO-PD</td><td>GPIO3</td><td>GPIO3</td></tr>
<tr><td>6</td><td>-</td><td>IO-PD</td><td>GPIO4</td><td>GPIO4</td></tr>
<tr><td>7</td><td>-</td><td>IO-PD</td><td>GPIO5</td><td>GPIO5</td></tr>
<tr><td>8</td><td>6</td><td>IO-A</td><td>ADBUS0</td><td>ADBUS0</td></tr>
<tr><td>9</td><td>7</td><td>IO-A</td><td>ADBUS1</td><td>ADBUS1</td></tr>
<tr><td>10</td><td>8</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>11</td><td>9</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>12</td><td>10</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>13</td><td>11</td><td>IO-A</td><td>ADBUS2</td><td>ADBUS2</td></tr>
<tr><td>14</td><td>12</td><td>IO-A</td><td>ADBUS3</td><td>ADBUS3</td></tr>
<tr><td>15</td><td>13</td><td>IO-A</td><td>ADBUS4</td><td>ADBUS4</td></tr>
<tr><td>16</td><td>14</td><td>IO-A</td><td>ADBUS5</td><td>ADBUS5</td></tr>
<tr><td>17</td><td>15</td><td>IO-A</td><td>ADBUS6</td><td>ADBUS6</td></tr>
<tr><td>18</td><td>16</td><td>IO-A</td><td>ADBUS7</td><td>ADBUS7</td></tr>
<tr><td>19</td><td>17</td><td>IO-B</td><td>ACBUS0</td><td>BDBUS0</td></tr>
<tr><td>20</td><td>18</td><td>IO-B</td><td>ACBUS1</td><td>BDBUS1</td></tr>
<tr><td>21</td><td>19</td><td>IO-B</td><td>ACBUS2</td><td>BDBUS2</td></tr>
<tr><td>22</td><td>20</td><td>IO-B</td><td>ACBUS3</td><td>BDBUS3</td></tr>
<tr><td>23</td><td>21</td><td>IO-B</td><td>ACBUS4</td><td>BDBUS4</td></tr>
<tr><td>24</td><td>22</td><td>IO-B</td><td>ACBUS5</td><td>BDBUS5</td></tr>
<tr><td>25</td><td>23</td><td>IO-B</td><td>ACBUS6</td><td>BDBUS6</td></tr>
<tr><td>26</td><td>24</td><td>IO-B</td><td>ACBUS7</td><td>BDBUS7</td></tr>
<tr><td>27</td><td>25</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>28</td><td>26</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>29</td><td>27</td><td>clock</td><td>OSCI</td><td>OSCI</td></tr>
<tr><td>30</td><td>28</td><td>clock</td><td>OSCO</td><td>OSCO</td></tr>
<tr><td>31</td><td>29</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>32</td><td>30</td><td>power</td><td>VREGIN</td><td>VREGIN</td></tr>
<tr><td>33</td><td>31</td><td>power</td><td>VREGOUT</td><td>VREGOUT</td></tr>
<tr><td>34</td><td>32</td><td>power</td><td>FSOURCE</td><td>FSOURCE</td></tr>
<tr><td>35</td><td>33</td><td>power</td><td>VPP</td><td>VPP</td></tr>
<tr><td>36</td><td>34</td><td>IO-C</td><td>BDBUS0</td><td>CDBUS0</td></tr>
<tr><td>37</td><td>35</td><td>IO-C</td><td>BDBUS1</td><td>CDBUS1</td></tr>
<tr><td>38</td><td>36</td><td>IO-C</td><td>BDBUS2</td><td>CDBUS2</td></tr>
<tr><td>39</td><td>37</td><td>IO-C</td><td>BDBUS3</td><td>CDBUS3</td></tr>
<tr><td>40</td><td>38</td><td>IO-C</td><td>BDBUS4</td><td>CDBUS4</td></tr>
<tr><td>41</td><td>39</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>42</td><td>40</td><td>IO-C</td><td>BDBUS5</td><td>CDBUS5</td></tr>
<tr><td>43</td><td>41</td><td>IO-C</td><td>BDBUS6</td><td>CDBUS6</td></tr>
<tr><td>44</td><td>42</td><td>IO-C</td><td>BDBUS7</td><td>CDBUS7</td></tr>
<tr><td>45</td><td>43</td><td>IO-shared</td><td>SUSPEND#</td><td>SUSPEND#</td></tr>
<tr><td>46</td><td>-</td><td>IO-PD</td><td>GPIO6</td><td>GPIO6</td></tr>
<tr><td>47</td><td>44</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>48</td><td>45</td><td>IO-D</td><td>BCBUS0</td><td>DDBUS0</td></tr>
<tr><td>49</td><td>46</td><td>IO-D</td><td>BCBUS1</td><td>DDBUS1</td></tr>
<tr><td>50</td><td>47</td><td>IO-D</td><td>BCBUS2</td><td>DDBUS2</td></tr>
<tr><td>51</td><td>48</td><td>IO-D</td><td>BCBUS3</td><td>DDBUS3</td></tr>
<tr><td>52</td><td>49</td><td>IO-D</td><td>BCBUS4</td><td>DDBUS4</td></tr>
<tr><td>53</td><td>50</td><td>IO-D</td><td>BCBUS5</td><td>DDBUS5</td></tr>
<tr><td>54</td><td>51</td><td>power</td><td>VCCIO</td><td>VCCIO</td></tr>
<tr><td>55</td><td>-</td><td>power</td><td>GND</td><td>GND</td></tr>
<tr><td>56</td><td>52</td><td>IO-D</td><td>BCBUS6</td><td>DDBUS6</td></tr>
<tr><td>57</td><td>53</td><td>IO-D</td><td>BCBUS7</td><td>DDBUS7</td></tr>
<tr><td>58</td><td>-</td><td>IO-PD</td><td>GPIO7</td><td>GPIO7</td></tr>
<tr><td>59</td><td>54</td><td>IO-PD</td><td>GPIO2</td><td>GPIO2</td></tr>
<tr><td>60</td><td>55</td><td>IO-PD</td><td>GPIO1</td><td>GPIO1</td></tr>
<tr><td>61</td><td>56</td><td>IO-PD</td><td>GPIO0</td><td>GPIO0</td></tr>
<tr><td>62</td><td>57</td><td>power</td><td>VCC_USB</td><td>VCC_USB</td></tr>
<tr><td>63</td><td>58</td><td>USB</td><td>DM</td><td>DM</td></tr>
<tr><td>64</td><td>59</td><td>USB</td><td>DP</td><td>DP</td></tr>
<tr><td>65</td><td>60</td><td>reference</td><td>REF</td><td>REF</td></tr>
<tr><td>66</td><td>61</td><td>power</td><td>VCC_PD</td><td>VCC_PD</td></tr>
<tr><td>67</td><td>62</td><td>PD</td><td>PD1_CC2</td><td>PD1_CC2</td></tr>
<tr><td>68</td><td>63</td><td>PD</td><td>PD1_SVBUS</td><td>PD1_SVBUS</td></tr>
<tr><td>69</td><td>64</td><td>PD</td><td>PD1_VCONN</td><td>PD1_VCONN</td></tr>
<tr><td>70</td><td>65</td><td>PD</td><td>PD1_CC1</td><td>PD1_CC1</td></tr>
<tr><td>71</td><td>-</td><td>PD</td><td>PD2_CC1</td><td>PD2_CC1</td></tr>
<tr><td>72</td><td>-</td><td>PD</td><td>PD2_SVBUS</td><td>PD2_SVBUS</td></tr>
<tr><td>73</td><td>-</td><td>PD</td><td>PD2_CC2</td><td>PD2_CC2</td></tr>
<tr><td>74</td><td>66</td><td>power</td><td>VCORE</td><td>VCORE</td></tr>
<tr><td>75</td><td>67</td><td>IO-shared</td><td>PWREN#</td><td>PWREN#</td></tr>
<tr><td>76</td><td>68</td><td>EEPROM</td><td>EECS</td><td>EECS</td></tr>
</tbody></table>
</div>
<h2 id="pin-functions-per-mode--ft2232h"><a class="header" href="#pin-functions-per-mode--ft2232h">Pin functions per mode — FT2232H</a></h2>
<div class="table-wrapper"><table><thead><tr><th>pin</th><th>UART</th><th>FIFO</th><th>sync FIFO</th><th>CPU FIFO</th><th>bitbang</th><th>MPSSE</th><th>MCU bus</th><th>opto-isolated</th></tr></thead><tbody>
<tr><td>ADBUS0</td><td>TXD</td><td>D0</td><td>D0</td><td>D0</td><td>D0</td><td>TCK/SK</td><td>AD0</td><td>-</td></tr>
<tr><td>ADBUS1</td><td>RXD</td><td>D1</td><td>D1</td><td>D1</td><td>D1</td><td>TDI/DO</td><td>AD1</td><td>-</td></tr>
<tr><td>ADBUS2</td><td>RTS#</td><td>D2</td><td>D2</td><td>D2</td><td>D2</td><td>TDO/DI</td><td>AD2</td><td>-</td></tr>
<tr><td>ADBUS3</td><td>CTS#</td><td>D3</td><td>D3</td><td>D3</td><td>D3</td><td>TMS/CS</td><td>AD3</td><td>-</td></tr>
<tr><td>ADBUS4</td><td>DTR#</td><td>D4</td><td>D4</td><td>D4</td><td>D4</td><td>GPIOL0</td><td>AD4</td><td>-</td></tr>
<tr><td>ADBUS5</td><td>DSR#</td><td>D5</td><td>D5</td><td>D5</td><td>D5</td><td>GPIOL1</td><td>AD5</td><td>-</td></tr>
<tr><td>ADBUS6</td><td>DCD#</td><td>D6</td><td>D6</td><td>D6</td><td>D6</td><td>GPIOL2</td><td>AD6</td><td>-</td></tr>
<tr><td>ADBUS7</td><td>RI#</td><td>D7</td><td>D7</td><td>D7</td><td>D7</td><td>GPIOL3</td><td>AD7</td><td>-</td></tr>
<tr><td>ACBUS0</td><td>TXDEN</td><td>RXF#</td><td>RXF#</td><td>CS#</td><td>-</td><td>GPIOH0</td><td>A8</td><td>-</td></tr>
<tr><td>ACBUS1</td><td>-</td><td>TXE#</td><td>TXE#</td><td>A0</td><td>WR#</td><td>GPIOH1</td><td>A9</td><td>-</td></tr>
<tr><td>ACBUS2</td><td>-</td><td>RD#</td><td>RD#</td><td>RD#</td><td>RD#</td><td>GPIOH2</td><td>A10</td><td>-</td></tr>
<tr><td>ACBUS3</td><td>RXLED#</td><td>WR</td><td>WR</td><td>WR#</td><td>-</td><td>GPIOH3</td><td>A11</td><td>-</td></tr>
<tr><td>ACBUS4</td><td>TXLED#</td><td>SI/WU</td><td>SI/WU</td><td>SI/WU</td><td>SI/WU</td><td>GPIOH4</td><td>A12</td><td>-</td></tr>
<tr><td>ACBUS5</td><td>-</td><td>-</td><td>CLKOUT</td><td>-</td><td>-</td><td>GPIOH5</td><td>A13</td><td>-</td></tr>
<tr><td>ACBUS6</td><td>-</td><td>-</td><td>OE#</td><td>-</td><td>-</td><td>GPIOH6</td><td>A14</td><td>-</td></tr>
<tr><td>ACBUS7</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>GPIOH7</td><td>A15</td><td>-</td></tr>
<tr><td>BDBUS0</td><td>TXD</td><td>D0</td><td>N/A</td><td>D0</td><td>D0</td><td>TCK/SK</td><td>CS#</td><td>FSDI</td></tr>
<tr><td>BDBUS1</td><td>RXD</td><td>D1</td><td>N/A</td><td>D1</td><td>D1</td><td>TDI/DO</td><td>ALE</td><td>FSCLK</td></tr>
<tr><td>BDBUS2</td><td>RTS#</td><td>D2</td><td>N/A</td><td>D2</td><td>D2</td><td>TDO/DI</td><td>RD#</td><td>FSDO</td></tr>
<tr><td>BDBUS3</td><td>CTS#</td><td>D3</td><td>N/A</td><td>D3</td><td>D3</td><td>TMS/CS</td><td>WR#</td><td>FSCTS</td></tr>
<tr><td>BDBUS4</td><td>DTR#</td><td>D4</td><td>N/A</td><td>D4</td><td>D4</td><td>GPIOL0</td><td>IORDY</td><td>-</td></tr>
<tr><td>BDBUS5</td><td>DSR#</td><td>D5</td><td>N/A</td><td>D5</td><td>D5</td><td>GPIOL1</td><td>CLKOUT</td><td>-</td></tr>
<tr><td>BDBUS6</td><td>DCD#</td><td>D6</td><td>N/A</td><td>D6</td><td>D6</td><td>GPIOL2</td><td>I/O0</td><td>-</td></tr>
<tr><td>BDBUS7</td><td>RI#</td><td>D7</td><td>N/A</td><td>D7</td><td>D7</td><td>GPIOL3</td><td>I/O1</td><td>-</td></tr>
<tr><td>BCBUS0</td><td>TXDEN</td><td>RXF#</td><td>N/A</td><td>CS#</td><td>-</td><td>GPIOH0</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS1</td><td>SLEEP#</td><td>TXE#</td><td>N/A</td><td>A0</td><td>WR#</td><td>GPIOH1</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS2</td><td>RXLED#</td><td>RD#</td><td>N/A</td><td>RD#</td><td>RD#</td><td>GPIOH2</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS3</td><td>TXLED#</td><td>WR</td><td>N/A</td><td>WR#</td><td>-</td><td>GPIOH3</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS4</td><td>SI/WU</td><td>SI/WU</td><td>N/A</td><td>SI/WU</td><td>SI/WU</td><td>GPIOH4</td><td>-</td><td>SI/WU</td></tr>
<tr><td>BCBUS5</td><td>-</td><td>-</td><td>N/A</td><td>-</td><td>-</td><td>GPIOH5</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS6</td><td>-</td><td>-</td><td>N/A</td><td>-</td><td>-</td><td>GPIOH6</td><td>-</td><td>-</td></tr>
<tr><td>BCBUS7</td><td>PWRSAV#</td><td>PWRSAV#</td><td>N/A</td><td>PWRSAV#</td><td>PWRSAV#</td><td>GPIOH7</td><td>PWRSAV#</td><td>PWRSAV#</td></tr>
</tbody></table>
</div>
<p>NOTE: The pin mapping is changed from FT2232C/D for many modes.</p>
<p>PWRSAV# is a device input that, if enabled in EEPROM, will force the device into suspend mode when low.  It can be connected to VBUS/GND via a resistor ladder to force-suspend a self-powered device when not connected to USB.</p>
<h2 id="pin-functions-per-mode--ft4232h"><a class="header" href="#pin-functions-per-mode--ft4232h">Pin functions per mode — FT4232H</a></h2>
<div class="table-wrapper"><table><thead><tr><th>pin</th><th>UART</th><th>bitbang</th><th>MPSSE</th></tr></thead><tbody>
<tr><td>*DBUS0</td><td>TXD</td><td>D0</td><td>TCK/SK</td></tr>
<tr><td>*DBUS1</td><td>RXD</td><td>D1</td><td>TDI/DO</td></tr>
<tr><td>*DBUS2</td><td>RTS#</td><td>D2</td><td>TDO/SI</td></tr>
<tr><td>*DBUS3</td><td>CTS#</td><td>D3</td><td>TMS/CS</td></tr>
<tr><td>*DBUS4</td><td>DTR#</td><td>D4</td><td>GPIOL0</td></tr>
<tr><td>*DBUS5</td><td>DSR#</td><td>D5</td><td>GPIOL1</td></tr>
<tr><td>*DBUS6</td><td>DCD#</td><td>D6</td><td>GPIOL2</td></tr>
<tr><td>*DBUS7</td><td>RI# or TXDEN (selected in EEPROM)</td><td>D7</td><td>GPIOL3</td></tr>
</tbody></table>
</div>
<h2 id="eeprom-data-format-3"><a class="header" href="#eeprom-data-format-3">EEPROM data format</a></h2>
<p>The device will accept 64-word, 128-word, and 256-word EEPROMs.  In case of 256-word EEPROMs, only first half is covered by the checksum.  The other half can still be used to store user data.</p>
<p>For USB-PD devices, a 256-word EEPROM is required for the USB-PD part of the device to function.  The second half of the EEPROM is used to store the USB-PD configuration data, and it has its own, separate checksum.  It is described on the <a href="usb-pd.html#eeprom-data-format">USB-PD page</a>.</p>
<ul>
<li>word 0x00 (FT2232H):
<ul>
<li>bits 0-2: channel A mode
<ul>
<li>0: UART</li>
<li>1: <a href="fifo.html">245-style FIFO</a></li>
<li>2: <a href="fifo.html">CPU FIFO</a></li>
<li>4: <a href="opto.html">fast opto-isolated serial</a></li>
</ul>
</li>
<li>bit 3: channel A enable bind to VCP driver</li>
<li>bits 8-10: channel B mode (see above)</li>
<li>bit 11: channel B enable bind to VCP driver</li>
<li>bit 15: enable PWRSAV# function on BCBUS7</li>
</ul>
</li>
<li>word 0x00 (FT4232H):
<ul>
<li>bit 3: channel A enable bind to VCP driver</li>
<li>bit 7: channel C enable bind to VCP driver</li>
<li>bit 11: channel B enable bind to VCP driver</li>
<li>bit 15: channel D enable bind to VCP driver</li>
</ul>
</li>
<li>word 0x01: idVendor (USB VID)</li>
<li>word 0x02: idProduct (USB PID)</li>
<li>word 0x03: bcdDevice (see table)</li>
<li>word 0x04: USB config (goes straight to configuration descriptor)
<ul>
<li>bits 0-7: bmAttributes
<ul>
<li>bit 5: remote wakeup enabled</li>
<li>bit 6: self-powered</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>bits 8-15: bMaxPower (max power in units of 2mA)</li>
</ul>
</li>
<li>word 0x05: device control
<ul>
<li>bit 2: IO pulldown in suspend</li>
<li>bit 3: serial number enabled</li>
<li>bit 12 (FT423[23]* only): ADBUS7 function in UART mode
<ul>
<li>0: RI</li>
<li>1: TXDEN</li>
</ul>
</li>
<li>bit 13 (FT423[23]* only): BDBUS7 function in UART mode</li>
<li>bit 14 (FT423[23]* only): CDBUS7 function in UART mode</li>
<li>bit 15 (FT423[23]* only): DDBUS7 function in UART mode</li>
</ul>
</li>
<li>word 0x06: controls electrical characteristics of channel IO pins; the IO-* names match the pin categories in the pinout table above. on FT4232H, they correspond directly to channels, while on FT2232H, CBUS and DBUS of each channel can be controlled independently
<ul>
<li>bits 0-1: IO-A pin drive strength
<ul>
<li>0: 4mA</li>
<li>1: 8mA</li>
<li>2: 12mA</li>
<li>3: 16mA</li>
</ul>
</li>
<li>bit 2: IO-A pin slow slew rate</li>
<li>bit 3: IO-A pin schmitt trigger</li>
<li>bits 4-5: IO-B drive strength</li>
<li>bit 6: IO-B slow slew rate</li>
<li>bit 7: IO-B schmitt trigger</li>
<li>bits 8-9: IO-C drive strength</li>
<li>bit 10: IO-C slow slew rate</li>
<li>bit 11: IO-C schmitt trigger</li>
<li>bits 12-13: IO-D drive strength</li>
<li>bit 14: IO-D slow slew rate</li>
<li>bit 15: IO-D schmitt trigger</li>
</ul>
</li>
<li>word 0x07: manufacturer string pointer</li>
<li>word 0x08: product description string pointer</li>
<li>word 0x09: serial number string pointer</li>
<li>word 0x0a: ???</li>
<li>word 0x0b:
<ul>
<li>bits 3-4: TPRDRV (an obscure undocumented trim parameter for the USB HS PHY)</li>
</ul>
</li>
<li>word 0x0c: EEPROM type
<ul>
<li>0x46: 93C46 (64-word)</li>
<li>0x56: 93C56 (128-word)</li>
<li>0x66: 93C66 (256-word)</li>
</ul>
</li>
<li>for 64-word EEPROM:
<ul>
<li>words 0x0d..0x3f: string / user area</li>
<li>word 0x3f: checksum</li>
</ul>
</li>
<li>for 128-word and 256-word EEPROM:
<ul>
<li>words 0xd..0x4d: user area
<ul>
<li>word 0x2b: for some reason, set to 0x302 by default (concidentally or not, this corresponds to a header of an empty string descriptor)</li>
</ul>
</li>
<li>words 0x4d..0x7f: string / user area</li>
<li>word 0x7f: checksum</li>
</ul>
</li>
</ul>
<p>String pointers are formatted as follows:</p>
<ul>
<li>for 64-word EEPROM:
<ul>
<li>bits 0-6: pointer to descriptor within EEPROM (counted <em>in bytes</em>)</li>
<li>bit 7: always set to 1</li>
</ul>
</li>
<li>for 128-word or 256-word EEPROM: pointer to descriptor within EEPROM (counted <em>in bytes</em>); note that FTDI tools will only store string descriptors in the area starting at word 0x4d, ensuring the high bit is always set</li>
<li>bits 8-15: total length of descriptor in bytes</li>
</ul>
<p>TODO: figure out wtf it is with the always-set high bit</p>
<p>The string descriptors are stored in ROM with the descriptor header included, as follows:</p>
<ul>
<li>word 0: header
<ul>
<li>bits 0-7: total length of descriptor in bytes (includes header)</li>
<li>bits 8-15: descriptor type (always 3 — string)</li>
</ul>
</li>
<li>words 1 and up: string in UTF-16</li>
</ul>
<p>The checksum can be computed as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checksum(eeprom: &amp;[u16]) -&gt; u16 {
    let checksum_word = match eeprom.len() {
        0x40 =&gt; 0x3f,
        0x80 | 0x100 =&gt; 0x7f,
    };
    let mut res: u16 = 0xaaaa;
    for pos in 0..checksum_word { // checksum word is NOT included — we're calculating it
        res ^= eeprom[pos];
        res = res.rotate_left(1);
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft232h-1"><a class="header" href="#ft232h-1">FT232H</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft-x-series-1"><a class="header" href="#ft-x-series-1">FT-X series</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ft4222h-1"><a class="header" href="#ft4222h-1">FT4222H</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb-pd-devices"><a class="header" href="#usb-pd-devices">USB-PD devices</a></h1>
<p>The <a href="ft2232h.html">FT2232H, FT4232H</a>, and <a href="ft232h.html">FT232H</a> devices have variants with USB-PD support.  They essentially consist of the base device and a USB-PD controller core put together with some super glue.  The USB-PD part is described here.</p>
<p>The devices are:</p>
<ul>
<li>FT2233HP: FT2232H with two USB-PD ports</li>
<li>FT4233HP: FT4232H with two USB-PD ports</li>
<li>FT2232HP: FT2232H with one USB-PD port</li>
<li>FT4232HP: FT4232H with one USB-PD port</li>
<li>FT233HP: FT232H with two USB-PD ports</li>
<li>FT232HP: FT232H with one USB-PD port</li>
</ul>
<p>TODO</p>
<h2 id="eeprom-data-format-4"><a class="header" href="#eeprom-data-format-4">EEPROM data format</a></h2>
<p>A 256-word EEPROM is required for the USB-PD part of the device to function.  The second half of the EEPROM is used to store the USB-PD configuration data.</p>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
