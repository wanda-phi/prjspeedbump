<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D2xx protocol - Project Speedbump</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Project Speedbump</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="d2xx-protocol"><a class="header" href="#d2xx-protocol">D2xx protocol</a></h1>
<p>D2xx is the name of protocol used by most FTDI USB devices.  It was originally made for the UART function of the FT8U100A, and remains quite UART-oriented.  However, FTDI has reused it for all kinds of stream-based interfaces.</p>
<h2 id="channels-and-interfaces"><a class="header" href="#channels-and-interfaces">Channels and interfaces</a></h2>
<p>A D2xx device can have one or more channels.  A channel is, at the core, a bidirectional byte-oriented stream of data.</p>
<p>Channels are often identified by single letters, in order (A, B, C, D, ...).</p>
<p>Each channel is exposed as a separate USB interface.  Each interface has two bulk endpoints: IN and OUT.  In addition, a channel also makes use of D2xx-specific control requests on the default config pipe (endpoint 0).</p>
<p>Some devices have an undocumented option to use isochronous endpoints instead of bulk endpoints.  That options is undoubtedly broken in some completely hilarious ways.</p>
<h2 id="identifying-a-d2xx-device"><a class="header" href="#identifying-a-d2xx-device">Identifying a D2xx device</a></h2>
<p>Since all D2xx devices can have custom VIDs and PIDs programmed, there is no sure-fire way to identify a USB device as a D2xx device — you need to know what VID:PID you are looking for.  However, there are some predefined VID:PID combinations that will be used by default.  They are listed in the table on the <a href="devices.html#d2xx-devices">devices page</a>.</p>
<p>As you can see, FTDI used to reuse its VID:PID combinations for groups of similar devices for some time, but then decided to just start assigning new IDs for every new device.</p>
<p>Once something is known to be a FTD2xx device, further identification can be obtained from the <code>bcdDevice</code> field of USB descriptor.  The <code>bcdDevice</code> values are likewise listed on the <a href="devices.html#d2xx-devices">devices page</a>.  It is not clear whether the <code>bcdDevice</code> field may be overriden via EEPROM.</p>
<p>Even putting VID:PID and <code>bcdDevice</code> together, it is still not always possible to uniquely identify the device.  Usually, one can just live with the uncertainty.  However, there are some more checks that can be done for further identification:</p>
<ul>
<li>FT8U2xxA and FT2xxB can be told apart by attempting the <code>GET_LATENCY_TIMER</code> request — a failure implies A-series device, while a success implies B-series device</li>
<li>FT232R and FT245R can be told apart by a field in the internal EEPROM, which the vendor claims to not be modifiable by the user</li>
<li>likewise, FT-X series devices can be told apart to some extent by another EEPROM field</li>
</ul>
<h2 id="stream-protocol"><a class="header" href="#stream-protocol">Stream protocol</a></h2>
<p>Note: FT2xxR devices have configurable <code>wMaxPacketSize</code> field in the bulk endpoint descriptors.  There are devices in the wild where people have programmed the (invalid) value of 0 in that field.  In case a device is encountered with such value, it should be overriden in the driver to 64 bytes.</p>
<h3 id="in-endpoint"><a class="header" href="#in-endpoint">IN endpoint</a></h3>
<p>The IN endpoint of a channel is used to transfer byte stream data from the device to the user.  It involves a framing protocol: every packet transferred on the endpoint includes a header with modem and line status.  Packets are always at least 2 bytes long.  The packet format is as follows:</p>
<ul>
<li>byte 0: modem status (shows the most recent state of the modem status input pins)
<ul>
<li>bit 0: always 1?</li>
<li>bit 1: always 0?</li>
<li>bit 2: always 0?</li>
<li>bit 3: always 0?</li>
<li>TODO: allegedly high-speed devices have 0010 in low bits?</li>
<li>bit 4: CTS</li>
<li>bit 5: DSR</li>
<li>bit 6: RI</li>
<li>bit 7: DCD</li>
</ul>
</li>
<li>byte 1: line status
<ul>
<li>bit 0: data ready (???)</li>
<li>bit 1: overrun error (device received data on the business end when there was no more space in IN endpoint FIFO)</li>
<li>bit 2: parity error</li>
<li>bit 3: framing error</li>
<li>bit 4: break interrupt</li>
<li>bit 5: TX holding register (???)</li>
<li>bit 6: TX (OUT endpoint) FIFO is empty</li>
<li>bit 7: FIFO error (???)</li>
</ul>
</li>
<li>bytes 2 and up (if any): actual stream data</li>
</ul>
<p>As can be seen, the protocol is very UART-oriented.  The modem and line status bytes are present even for D2xx devices that have nothing to do with UART, though they are mostly dummied out in that case.  The TX FIFO empty bit is, however, generally useful.</p>
<p>TODO: kernel driver alleges that parity/framing errors are always associated with the last byte in the packet. Check this.</p>
<p>To avoid excessive load on the host, the device doesn't always transmit packets on the IN endpoint as soon as data is available.  Instead, the device will send a packet in the following circumstances:</p>
<ul>
<li>a full-sized packet has been filled</li>
<li>a special "event" character has been received (if enabled by driver)</li>
<li>data is available and the latency timer has expired
<ul>
<li>on FT8U2xxA (and FT8U100A?), the latency timer is always 16ms</li>
<li>on newer devices, the default latency timer is 16ms, but it can be configured to any value between 2ms and 255ms</li>
</ul>
</li>
<li>TODO: line errors / modem status changes too? kernel alleges device will send an update packet every 40ms even with no activity</li>
</ul>
<h3 id="out-endpoint"><a class="header" href="#out-endpoint">OUT endpoint</a></h3>
<p>There are two variants of the protocol with respect to OUT endpoint handling.</p>
<p>The original variant is present on the FT8U100A only.  In this variant, every OUT endpoint packet has to be prefixed with a header.  The packet then has the following format:</p>
<ul>
<li>byte 0: header
<ul>
<li>bit 0: must be 1</li>
<li>bit 1: must be 0</li>
<li>bits 2-7: length of payload (ie. length of packet, not including the header byte)</li>
</ul>
</li>
<li>bytes 1 and up: actual stream data</li>
</ul>
<p>Since the header is completely useless, it has been done away with in later devices.  In every device other than FT8U100A, the OUT endpoint is completely headerless and packets contain just the raw stream data.</p>
<h2 id="control-requests"><a class="header" href="#control-requests">Control requests</a></h2>
<p>The protocol includes the following control requests:</p>
<div class="table-wrapper"><table><thead><tr><th>request</th><th><code>bmRequestType</code></th><th><code>bRequest</code></th><th><code>wValue</code></th><th><code>wIndex</code></th><th>data</th></tr></thead><tbody>
<tr><td><code>RESET</code></td><td><code>0x40</code></td><td><code>0x00</code></td><td>reset kind</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_MODEM_CTRL</code></td><td><code>0x40</code></td><td><code>0x01</code></td><td>DTR + RTS state</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_FLOW_CTRL</code></td><td><code>0x40</code></td><td><code>0x02</code></td><td>XON / XOFF chars</td><td>channel + mode</td><td>-</td></tr>
<tr><td><code>SET_BAUD_RATE</code></td><td><code>0x40</code></td><td><code>0x03</code></td><td>divisor low bits</td><td>channel + divisor high bits</td><td>-</td></tr>
<tr><td><code>SET_DATA_CHARACTERISTICS</code></td><td><code>0x40</code></td><td><code>0x04</code></td><td>data format + break state</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_MODEM_STATUS</code></td><td><code>0xc0</code></td><td><code>0x05</code></td><td>0</td><td>channel</td><td>2 bytes</td></tr>
<tr><td><code>SET_EVENT_CHAR</code></td><td><code>0x40</code></td><td><code>0x06</code></td><td>event char + enable</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_ERROR_CHAR</code></td><td><code>0x40</code></td><td><code>0x07</code></td><td>error char + enable</td><td>channel</td><td>-</td></tr>
<tr><td><code>SET_LATENCY_TIMER</code></td><td><code>0x40</code></td><td><code>0x09</code></td><td>latency timer</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_LATENCY_TIMER</code></td><td><code>0xc0</code></td><td><code>0x0a</code></td><td>0</td><td>channel</td><td>1 byte</td></tr>
<tr><td><code>SET_BITMODE</code></td><td><code>0x40</code></td><td><code>0x0b</code></td><td>bit mode + output mask</td><td>channel</td><td>-</td></tr>
<tr><td><code>GET_PIN_STATE</code></td><td><code>0xc0</code></td><td><code>0x0c</code></td><td>0</td><td>channel</td><td>1 byte</td></tr>
<tr><td><code>VENDOR_CMD_GET</code></td><td><code>0xc0</code></td><td><code>0x20</code></td><td>request</td><td>channel</td><td>up to 0x80 bytes</td></tr>
<tr><td><code>VENDOR_CMD_SET</code></td><td><code>0x40</code></td><td><code>0x21</code></td><td>request + data</td><td>channel</td><td>up to 0x80 bytes</td></tr>
<tr><td><code>READ_EEPROM</code></td><td><code>0xc0</code></td><td><code>0x90</code></td><td>0</td><td>word address</td><td>2 bytes</td></tr>
<tr><td><code>WRITE_EEPROM</code></td><td><code>0x40</code></td><td><code>0x91</code></td><td>word value</td><td>word address</td><td>-</td></tr>
<tr><td><code>ERASE_EEPROM</code></td><td><code>0x40</code></td><td><code>0x92</code></td><td>0</td><td>0</td><td>-</td></tr>
</tbody></table>
</div>
<p>Most control requests operate on a channel.  The channel is specified as follows:</p>
<ul>
<li>for single-channel devices: channel is 0</li>
<li>for multi-channel devices: the channel indices start at 1 (ie. channel number in control request is USB interface index + 1)
<ul>
<li>TODO: allegedly, specifying 0 means "all channels"?</li>
</ul>
</li>
</ul>
<p>The channel is usually stuffed directly into <code>wIndex</code>.  However, there are variations to keep you on your toes.</p>
<h3 id="reset"><a class="header" href="#reset"><code>RESET</code></a></h3>
<p>Resets the device or purges IN/OUT endpoint buffers on device.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x00</code></li>
<li><code>wValue</code>: kind of reset to perform
<ul>
<li>0: reset the serial engine
<ul>
<li>purge both IN and OUT endpoints</li>
<li>disable event char and set it to <code>0x0d</code> (<code>'\r'</code>)</li>
<li>disable flow control</li>
<li>clear DTR and RTS</li>
</ul>
</li>
<li>1: purge OUT endpoint (nuke all buffered data)</li>
<li>2: purge IN endpoint</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>TODO: determine <em>exactly</em> what the reset actually resets; the above list is according to the kernel sources.</p>
<p>TODO: libftd2xx seems to always send resets with <code>wIndex</code> set to 0; is this a bug?</p>
<h3 id="set_modem_ctrl"><a class="header" href="#set_modem_ctrl"><code>SET_MODEM_CTRL</code></a></h3>
<p>Changes the state of DTR and RTS lines.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op in non-UART modes)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x01</code></li>
<li><code>wValue</code>:
<ul>
<li>bit 0: new DTR value</li>
<li>bit 1: new RTS value</li>
<li>bit 8: change DTR (if not set, DTR will be unchanged)</li>
<li>bit 9: change RTS</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_flow_ctrl"><a class="header" href="#set_flow_ctrl"><code>SET_FLOW_CTRL</code></a></h3>
<p>Changes hardware flow control mode.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op in non-UART modes)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x02</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: XON character</li>
<li>bits 8-15: XOFF character</li>
</ul>
</li>
<li><code>wIndex</code>:
<ul>
<li>bits 0-7: channel</li>
<li>bit 8: enable RTS/CTS flow control</li>
<li>bit 9: enable DTR/DSR flow control</li>
<li>bit 10: enable XON/XOFF flow control</li>
</ul>
</li>
</ul>
<p>TODO: make double-sure of <code>wIndex</code> encoding</p>
<p>TODO: check if XON/XOFF is applicable to eg. FIFO mode</p>
<h3 id="set_baud_rate"><a class="header" href="#set_baud_rate"><code>SET_BAUD_RATE</code></a></h3>
<p>Sets the baud rate, and also the clock for bitbang and MPSSE modes.</p>
<ul>
<li>applicable to: all D2xx devices (but may be a no-op on MCU-based ones)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x03</code></li>
<li><code>wValue</code>: bits 0-15 of the divisor value</li>
<li><code>wIndex</code>:
<ul>
<li>for single-channel device:
<ul>
<li>bits 0-1: bits 16-17 of the divisor</li>
</ul>
</li>
<li>for multi-channel device:
<ul>
<li>bits 0-7: channel</li>
<li>bits 8-9: bits 16-17 of the divisor</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The format of the divisor varies depending on the exact device.</p>
<h4 id="ft8u100a"><a class="header" href="#ft8u100a">FT8U100A</a></h4>
<p>For FT8U100A, the divisor is an enum, selecting the baud rate from the following fixed list:</p>
<ul>
<li>0: 300 baud</li>
<li>1: 600</li>
<li>2: 1200</li>
<li>3: 2400</li>
<li>4: 4800</li>
<li>5: 9600</li>
<li>6: 19200</li>
<li>7: 38400</li>
<li>8: 57600</li>
<li>9: 115200</li>
</ul>
<h4 id="ft8u232a-ft8u245a"><a class="header" href="#ft8u232a-ft8u245a">FT8U232A, FT8U245A</a></h4>
<p>These devices run on 48MHz base clock.  The base clock is divided by a fractional divisor to obtain the channel clock.  The channel clock is then further divided by 16 to obtain the baud rate.</p>
<p>The divisor is encoded into a 16-bit number as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special case below)</li>
<li>bits 14-15: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
</ul>
</li>
</ul>
<p>There is also a special divisor with dedicated encoding:</p>
<ul>
<li><code>0x0000</code> encodes a special divisor of 1 (corresponding to 3000000 baud rate)</li>
</ul>
<h4 id="ft232b-ft245b-ft232r-ft245r-ft2232cdl-ft-x-series"><a class="header" href="#ft232b-ft245b-ft232r-ft245r-ft2232cdl-ft-x-series">FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT-X series</a></h4>
<p>These devices are similar to FT8U2xxA, with minor extensions.  The encoding scheme is backwards-compatible.</p>
<p>The divisor is encoded into a 17-bit number (with top bit overflowing into the <code>wIndex</code> field) as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special cases below)</li>
<li>bits 14-16: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
<li>4: .375</li>
<li>5: .675</li>
<li>6: .75</li>
<li>7: .875</li>
</ul>
</li>
</ul>
<p>There are also two special divisors with dedicated encoding:</p>
<ul>
<li><code>0x0000</code> encodes a special divisor of 1 (corresponding to 3000000 baud rate)</li>
<li><code>0x0001</code> encodes a special divisor of 1.5 (corresponding to 2000000 baud rate)</li>
</ul>
<p>In addition to providing the UART baud rate, the channel clock (not divided by 16) is also used for other modes such as bitbang and MPSSE.</p>
<h4 id="ft2232h-ft4232h-ft232h-and-all-their-variants"><a class="header" href="#ft2232h-ft4232h-ft232h-and-all-their-variants">FT2232H, FT4232H, FT232H (and all their variants)</a></h4>
<p>These devices are USB high-speed peripherials, and support a higher baud rate and channel clock range.  The base clock of the device is 120MHz.  The divisor encoding is an extension of the one used in FT232B, and is backwards compatible.</p>
<p>The divisor is encoded into an 18-bit number (with top two bits overflowing into the <code>wIndex</code> field) as follows:</p>
<ul>
<li>bits 0-13: integer part (must be at least 2, except for the special cases below)</li>
<li>bits 14-16: fractional part, encoded
<ul>
<li>0: .0</li>
<li>1: .5</li>
<li>2: .25</li>
<li>3: .125</li>
<li>4: .375</li>
<li>5: .675</li>
<li>6: .75</li>
<li>7: .875</li>
</ul>
</li>
<li>bit 17: divisor and UART mode
<ul>
<li>0: low-speed, FT232B compatible:
<ul>
<li>base 120MHz clock is pre-divided by 2.5 into a 48MHz clock before being put through the divisor</li>
<li>baud rate is channel clock divided by 16</li>
</ul>
</li>
<li>1: high-speed:
<ul>
<li>base 120MHz clock is fed directly into the divisor</li>
<li>baud rate is channel clock divided by 10</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>There are also two special divisors with dedicated encoding:</p>
<ul>
<li><code>0x00000</code> or <code>0x20000</code> encodes a special divisor of 1 (corresponding to low-speed 3000000 or high-speed 12000000 baud rate, respectively)</li>
<li><code>0x00001</code> or <code>0x20001</code> encodes a special divisor of 1.5 (corresponding to low-speed 2000000 or high-speed 8000000 baud rate, respectively)</li>
</ul>
<p>In addition to providing the UART baud rate, the channel clock (not divided by 10 or 16) is also used for other modes such as bitbang and MPSSE.</p>
<p>Note that, while the new high-speed divisor mode is usually preferable due to more precision, it cannot represent some of the lowest baud rates (600 baud and below). The low-speed mode should be used for those.</p>
<h3 id="set_data_characteristics"><a class="header" href="#set_data_characteristics"><code>SET_DATA_CHARACTERISTICS</code></a></h3>
<p>Sets the UART data format and break state.</p>
<ul>
<li>applicable to: all D2xx devices (but will be a no-op in non-UART mode)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x04</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: number of data bits (7-8; allegedly FT8U100A can also do 5-6)</li>
<li>bits 8-10: parity mode
<ul>
<li>0: none</li>
<li>1: odd</li>
<li>2: even</li>
<li>3: mark</li>
<li>4: space</li>
</ul>
</li>
<li>bits 11-13: stop bits
<ul>
<li>0: 1 bit</li>
<li>1: 1.5 bits (support status unclear)</li>
<li>2: 2 bits</li>
</ul>
</li>
<li>bit 14: transmitter in break state if set</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="get_modem_status"><a class="header" href="#get_modem_status"><code>GET_MODEM_STATUS</code></a></h3>
<p>Returns current modem status and line status.  This is the same information that is transmitted in the packet header bytes on the IN endpoint.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x05</code></li>
<li><code>wValue</code>: <code>0</code></li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: <code>2</code></li>
<li>data:
<ul>
<li>byte 0: modem status (shows the most recent state of the modem status input pins)
<ul>
<li>bit 0: always 1?</li>
<li>bit 1: always 0?</li>
<li>bit 2: always 0?</li>
<li>bit 3: always 0?</li>
<li>TODO: allegedly high-speed devices have 0010 in low bits?</li>
<li>bit 4: CTS</li>
<li>bit 5: DSR</li>
<li>bit 6: RI</li>
<li>bit 7: DCD</li>
</ul>
</li>
<li>byte 1: line status
<ul>
<li>bit 0: data ready (???)</li>
<li>bit 1: overrun error (device received data on the business end when there was no more space in IN endpoint FIFO)</li>
<li>bit 2: parity error</li>
<li>bit 3: framing error</li>
<li>bit 4: break interrupt</li>
<li>bit 5: TX holding register (???)</li>
<li>bit 6: TX (OUT endpoint) FIFO is empty</li>
<li>bit 7: FIFO error (???)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TODO: allegedly FT8U100A only returns the first byte?</p>
<h3 id="set_event_char"><a class="header" href="#set_event_char"><code>SET_EVENT_CHAR</code></a></h3>
<p>Sets the special "event" character.  Whenever a matching byte is received on the business end of the device, a packet will be sent on the IN endpoint immediately, instead of waiting for the buffer to fill completely or for the latency timer to expire.  This can be eg. set to <code>0x0d</code> (CR) to immediately present received lines to the host.</p>
<ul>
<li>applicable to: all D2xx devices</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x06</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: event character</li>
<li>bit 8: event character enable (if unset, no event character processing is done)</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_error_char"><a class="header" href="#set_error_char"><code>SET_ERROR_CHAR</code></a></h3>
<p>Sets the special "error" character that will be inserted into the receive FIFO in place of parity and framing errors.</p>
<ul>
<li>applicable to: all D2xx devices (but will be a no-op in non-UART mode)</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x07</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: error character</li>
<li>bit 8: error character enable (if unset, parity and framing errors do not insert anything into the FIFO)</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<h3 id="set_latency_timer"><a class="header" href="#set_latency_timer"><code>SET_LATENCY_TIMER</code></a></h3>
<p>Sets the latency timer (see IN endpoint description).</p>
<ul>
<li>applicable to: everything except FT8U100A, FT8U232A, FT8U245A</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x09</code></li>
<li><code>wValue</code>: latency timer, in units of 1ms (2 to 255)</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>Note: on FT232R and FT245R this command is also used as EEPROM write unlock. The latency timer has to be set to <code>0x77</code> to enable EEPROM writes.  Otherwise, the write commands get ignored.</p>
<h3 id="get_latency_timer"><a class="header" href="#get_latency_timer"><code>GET_LATENCY_TIMER</code></a></h3>
<p>Reads back the latency timer (see IN endpoint description).  Also useful for telling FT8U2xxA and FT2xxB apart.</p>
<ul>
<li>applicable to: everything except FT8U100A, FT8U232A, FT8U245A</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x0a</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: 1</li>
<li>data: latency timer (1 byte)</li>
</ul>
<h3 id="set_bitmode"><a class="header" href="#set_bitmode"><code>SET_BITMODE</code></a></h3>
<p>Sets a special mode on the channel, overriding whatever base mode it has.</p>
<ul>
<li>applicable to: FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series
<ul>
<li>async bitbang: all of the above devices</li>
<li>MPSSE: FT2232[CDL] (channel A only), FT2232H, FT4232H (channel A and B only), FT232H</li>
<li>sync bitbang: FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li>MCU host bus: FT2232[CDL], FT2232H</li>
<li>fast opto-isolated serial: FT2232[CDL], FT2232H, FT232H</li>
<li>CBUS bit-bang: FT232R, FT232H, FT-X series</li>
<li>synchronous 245-style FIFO: FT2232H, FT232H</li>
<li>FT1248: FT232H maybe?!?</li>
</ul>
</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x09</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: depends on mode
<ul>
<li>async and sync bit-bang: mask of which data pins are outputs (0 is input, 1 is output)</li>
<li>CBUS bit-bang:
<ul>
<li>bits 0-3: output data</li>
<li>bits 4-7: output pin mask (0 is input, 1 is output)</li>
</ul>
</li>
<li>others: unused?</li>
</ul>
</li>
<li>bits 8-15: mode
<ul>
<li>0x00: reset to base mode</li>
<li>0x01: <a href="bitbang.html">async bit-bang</a></li>
<li>0x02: <a href="mpsse.html">MPSSE</a></li>
<li>0x04: <a href="bitbang.html">sync bit-bang</a></li>
<li>0x08: <a href="mcu-bus.html">MCU host bus</a></li>
<li>0x10: reset <a href="opto.html">fast opto-isolated serial</a> (?!?!?)</li>
<li>0x20: <a href="bitbang.html">CBUS bit-bang</a></li>
<li>0x40: <a href="fifo.html">synchronous 245-style FIFO</a></li>
<li>0x80: allegedly <a href="ft1248.html">FT1248</a> according to libftdi (?!?!?)</li>
</ul>
</li>
</ul>
</li>
<li><code>wIndex</code>: channel</li>
</ul>
<p>TODO: figure out the details of this cursed thing</p>
<p>TODO: why are FT1248 and fast opto-isolated serial set both here and in the EEPROM</p>
<p>TODO: CBUS bit-bang has special semantics and can be combined with base mode?!? figure that out</p>
<h3 id="get_pin_state"><a class="header" href="#get_pin_state"><code>GET_PIN_STATE</code></a></h3>
<p>Reads current raw state of the channel's DBUS pins.</p>
<p>FTDI calls this request <code>GET_BITMODE</code>. However, this naming decision is a crime against catgirlkind, and we shall not respect it.</p>
<ul>
<li>applicable to: FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x0c</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: channel</li>
<li><code>wLength</code>: 1</li>
<li>data: pin state</li>
</ul>
<p>TODO: allegedly this reads CBUS state instead of DBUS state when in CBUS bit-bang mode</p>
<h3 id="vendor_cmd_get"><a class="header" href="#vendor_cmd_get"><code>VENDOR_CMD_GET</code></a></h3>
<p>Does a vendor-specific operation with get semantics.  Corresponds to <code>FT_VendorCmdGet</code> and <code>FT_VendorCmdGetEx</code>.</p>
<p>You may be asking yourself why FTDI saw fit to create a space for vendor-defined requests within its vendor-defined requests space as defined by USB, given that it is the defining vendor in both cases.  The answer is that I have no meowing idea.  However, this seems to be where they stuff a bunch of subcommands specific to their weirder devices.</p>
<ul>
<li>applicable to: FT4222H, allegedly UMFTPD3A</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x20</code></li>
<li><code>wValue</code>: request type</li>
<li><code>wIndex</code>: channel (or not, it's vendor-defined after all)</li>
<li><code>wLength</code>: up to <code>0x80</code></li>
</ul>
<p>The request set appears to be specific to the exact device.  For the FT4222H request list, see [TODO].</p>
<h3 id="vendor_cmd_set"><a class="header" href="#vendor_cmd_set"><code>VENDOR_CMD_SET</code></a></h3>
<p>Does a vendor-specific operation with set semantics.  Corresponds to <code>FT_VendorCmdSet</code>.</p>
<ul>
<li>applicable to: FT4222H, allegedly UMFTPD3A</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x21</code></li>
<li><code>wValue</code>:
<ul>
<li>bits 0-7: request type</li>
<li>bits 8-15: data, if a single byte of data is transferred</li>
</ul>
</li>
<li><code>wIndex</code>: channel (or not, it's vendor-defined after all)</li>
<li><code>wLength</code>: up to <code>0x80</code></li>
</ul>
<p>If exactly 1 byte is sent to the device, it is put in the high byte of <code>wValue</code>, and <code>wLength</code> is set to 0.  If more than 1 byte is sent to the device, they are all put in the data payload, and the high byte of <code>wValue</code> is unused.</p>
<p>The request set appears to be specific to the exact device.  For the FT4222H request list, see [TODO].</p>
<h3 id="read_eeprom"><a class="header" href="#read_eeprom"><code>READ_EEPROM</code></a></h3>
<p>Reads a 16-bit word from the EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0xc0</code></li>
<li><code>bRequest</code>: <code>0x90</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: word address to read; note that the address is counted in 16-bit words, not bytes</li>
<li><code>wLength</code>: 2</li>
<li>data: word from EEPROM (little-endian)</li>
</ul>
<p>The format of the EEPROM depends on the device.  See the documentation for the particular device.</p>
<h3 id="write_eeprom"><a class="header" href="#write_eeprom"><code>WRITE_EEPROM</code></a></h3>
<p>Writes a 16-bit word into the EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT232R, FT245R, FT2232[CDL], FT2232H, FT4232H, FT232H, FT-X series</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x91</code></li>
<li><code>wValue</code>: word to write to the EEPROM</li>
<li><code>wIndex</code>: word address to write; note that the address is counted in 16-bit words, not bytes</li>
</ul>
<p>Note: on FT232R and FT245R this command is only accepted when the latency timer is set to the magic <code>0x77</code> value.</p>
<p>Note that the EEPROM on FT232R and FT245R devices is 32-bit dword oriented, not 16-bit.  This is completely transparent on reads, but is significant for writes: FT2xxR EEPROM must always be written one aligned dword at a time, with the lower-address word written first.</p>
<p>TODO: what about FT-X series?</p>
<h3 id="erase_eeprom"><a class="header" href="#erase_eeprom"><code>ERASE_EEPROM</code></a></h3>
<p>Erases the entire EEPROM.</p>
<ul>
<li>applicable to: FT8U100A?, FT8U232A, FT8U245A, FT232B, FT245B, FT2232[CDL], FT2232H, FT4232H, FT232H</li>
<li><code>bmRequestType</code>: <code>0x40</code></li>
<li><code>bRequest</code>: <code>0x92</code></li>
<li><code>wValue</code>: 0</li>
<li><code>wIndex</code>: 0</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="devices.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="fifo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="devices.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="fifo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
